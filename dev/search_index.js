var documenterSearchIndex = {"docs":
[{"location":"curves/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Two type of curves are available:","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"B-splines curves\nNURBS curves","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Both are defined by initializing corresponding structures.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Define-Structures","page":"Curves","title":"Define Structures","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"NURBS and B-spline curves are defined by initializing a BsplineCurve or a NURBScurve structure, respectively.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using NURBS # hide\n# --- parameters\nkVec = Float64[0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 6, 6] # knot vector\nkVec ./= maximum(kVec)                                # normalize it\n\np = 3  # degree \n\n# --- control points\nusing StaticArrays\nP1 = SVector(0.0, 0.0, 0.0)\nP2 = SVector(0.1, 0.25, 0.0)\nP3 = SVector(0.25, 0.3, 0.0)\nP4 = SVector(0.3, 0.5, 0.0)\nP5 = SVector(0.4, 0.4, 0.0)\nP6 = SVector(0.6, 0.3, 0.0)\nP7 = SVector(0.8, 0.7, 1.0)\nP8 = SVector(1.0, 0.4, 0.0)\nP9 = SVector(1.1, 0.4, 0.0)\n\ncontrolPoints = [P1 , P2 , P3 , P4 , P5 , P6 , P7 , P8 , P9 ]\nw             = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 3.0, 1.0, 1.0] # weights for the NURBS\n\n# --- the structures\nNBspline = BsplineCurve(Bspline(p, kVec), controlPoints)\nNNurbs   = NURBScurve(NURB(p, kVec, w), controlPoints)\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Evaluate-Points-on-the-Curve","page":"Curves","title":"Evaluate Points on the Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"To evaluate the curves at parametric points the curvePoints function is provided. ","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"evalpoints = collect(0:0.0005:1.0)\n\nCBspline = curvePoints(NBspline, evalpoints)\nCNurbs   = curvePoints(NNurbs,   evalpoints)\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"To plot the curves the plotCurve3D and the plotCurve functions are provided, where the latter ignores any 'z'-components.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"note: Note\nThe PlotlyJS.jl package has to be loaded in order to make the functions available. Reason is the employed Requires.jl framework.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using PlotlyJS\n\nplotCurve3D(CBspline, controlPoints=controlPoints)\nt = plotCurve3D(CBspline, controlPoints=controlPoints) # hide\nsavefig(t, \"cruve3D.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"cruve3D.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Evaluate-Derivatives-of-the-Curve","page":"Curves","title":"Evaluate Derivatives of the Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"To evaluate derivatives of curves at parametric points the curveDerivativesPoints function is provided.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"evalpoints = collect(0:0.0005:1.0)\n\nC = curveDerivativesPoints(NNurbs, evalpoints, 2) # 0-th, 1st, and 2nd derivatives\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"The plotCurve3D function has an optional argument tangents to plot vectors at the points of the curve.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using PlotlyJS\n\nplotCurve3D(C[1], controlPoints=controlPoints, tangents=C[2])\nt = plotCurve3D(C[1], controlPoints=controlPoints, tangents=C[2]) # hide\nsavefig(t, \"cruve3Dder.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"cruve3Dder.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/","page":"API Reference","title":"API Reference","text":"Modules = [NURBS]","category":"page"},{"location":"apiref/#NURBS.Bspline","page":"API Reference","title":"NURBS.Bspline","text":"Bspline{F} <: Basis\n\nB-spline basis.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.BsplineCurve","page":"API Reference","title":"NURBS.BsplineCurve","text":"BsplineCurve{F} <: Curve\n\nB-spline curve defined by the basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.BsplineSurface","page":"API Reference","title":"NURBS.BsplineSurface","text":"BsplineSurface{F} <: Surface\n\nSurface defined by a B-spline basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURB","page":"API Reference","title":"NURBS.NURB","text":"NURB{F} <: Basis\n\nNURBS basis.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBScurve","page":"API Reference","title":"NURBS.NURBScurve","text":"NURBScurve{F} <: Curve\n\nB-spline curve defined by the basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBSsurface","page":"API Reference","title":"NURBS.NURBSsurface","text":"NURBSsurface{F} <: Surface\n\nSurface defined by a B-spline basis, the control points, and the weights.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.bSpline-Tuple{Bspline, Any}","page":"API Reference","title":"NURBS.bSpline","text":"bSpline(basis::Bspline, evalpoints)\n\nEvaluate B-spline basis at all evalpoints.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineDerivatives-Tuple{Bspline, Int64, Any}","page":"API Reference","title":"NURBS.bSplineDerivatives","text":"bSplineDerivatives(basis::Bspline, k::Int, evalpoints)\n\nEvaluate k-the derivative of B-spline basis at all evalpoints (all basis functions different from 0 at the evalpoints are evaluated).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Int64, Any}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, degree::Int, evalpoints; normalize=true)\n\ni-th b-spline basis function of degree 'degree' evaluated at all 'evalpoints'.\n\nThe knotvector is assumed to be normalized to [1, 0].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Int64, Real}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, degree::Int, u::Real)\n\ni-th b-spline basis function of degree 'degree' evaluated at u.\n\nFormula (2.5) of 'The NURBS Book' p. 50.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Real}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, u::Real)\n\ni-th b-spline basis function of degree 0 evaluated at u.\n\nFormula (2.5) of 'The NURBS Book' p. 50.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Bspline, Int64, Any}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(basis::Bspline, i::Int, evalpoints)\n\ni-th B-spline basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaiveDerivative-Tuple{Any, Int64, Int64, Any, Int64}","page":"API Reference","title":"NURBS.bSplineNaiveDerivative","text":"bSplineNaiveDer(knotVector, i::Int, degree::Int, evalpoints, k::Int; normalize=true)\n\nCompute the k-th derivative of i-th b-spline basis function of degree 'degree' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaiveDerivative-Tuple{Any, Int64, Int64, Real, Int64}","page":"API Reference","title":"NURBS.bSplineNaiveDerivative","text":"bSplineNaiveDerivative(knotVector, i::Int, degree::Int, u::Real, k::Int)\n\nk-th derivative of the i-th b-spline basis function of degree 'degree' evaluated at (single) point 'u'.\n\nFormula (2.9) of 'The NURBS Book' p. 61. (Recursive implementation to avoid the faculties in the (2.10) formula.)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaiveDerivative-Tuple{Bspline, Int64, Int64, Any}","page":"API Reference","title":"NURBS.bSplineNaiveDerivative","text":"bSplineNaiveDerivative(basis::Bspline, i::Int, k::Int, evalpoints)\n\nCompute the k-th derivative of i-th b-spline basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.basisFun-Tuple{Any, Any, Int64, Any}","page":"API Reference","title":"NURBS.basisFun","text":"basisFun(knotSpan, uVector, degree::Int, knotVector)\n\nCompute the nonvanishing B-spline basis functions of degree 'degree' at the parametric points defined by 'uVector'\n\nReturn the B-spline basis functions vector of size length(uVector) * (degree + 1).\n\nAdapted from Algorithm A2.2 from 'The NURBS Book' p. 70.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{BsplineCurve, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curveDerivativePoints(curve::BsplineCurve, uVector)\n\nConvenience function to compute points on the k-th derivative of a B-spline curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{Int64, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curveDerivativesPoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector, weights, k::Int)\n\nCompute points on the k-th derivatives of a NURBS curve: given the 'knotVector', the 'controlPoints', the 'degree', and the 'weights', the curve is evaluated at the points given in 'uVector'.\n\nUsing (4.8) on page 125 of 'The NURBS Book'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{Int64, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector)\n\nCompute a points on the k-th derivatives of a B-spline curve: given the 'knotVector', the 'controlPoints', and the 'degree', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{NURBScurve, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curveDerivativesPoints(curve::NURBScurve, uVector, k::Int)\n\nConvenience function to compute points on a NURBS curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{BsplineCurve, Any}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(curve::BsplineCurve, uVector)\n\nConvenience function to compute points on a B-spline curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{Int64, Any, Any, Any, Any}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector, weights)\n\nCompute points on a NURBS curve: given the 'knotVector', the 'controlPoints', the 'degree', and the 'weights', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{Int64, Any, Any, Any}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector)\n\nCompute a 1D B-spline curve: given the 'knotVector', the 'controlPoints', and the 'degree', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{NURBScurve, Any}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(curve::NURBScurve, uVector)\n\nConvenience function to compute points on a NURBS curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.derBasisFun-Tuple{Any, Int64, Any, Any, Int64}","page":"API Reference","title":"NURBS.derBasisFun","text":"derBasisFun(knotSpan, degree::Int, evalpoints, knotVector, numberDerivatives::Int)\n\nCompute the nonvanishing B-spline basis functions and its derivatives of degree 'degree' at the parametric points defined by 'uVector'.\n\nOrganization of output:  dersv[n, k, :] contains (k-1)-th derivative at n-th point.\n\nAdapted from Algorithm A2.3 from 'The NURBS BOOK' p. 72.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.findSpan-Tuple{Int64, Any, Any}","page":"API Reference","title":"NURBS.findSpan","text":"findSpan(n::Int, u, knotVector)\n\nFind the spans of a B-spline knot vector at the parametric points 'u', where 'b' is the number of basis functions (control points).\n\nSpan: the intervall index in which a point lies. E.g., knotVector = [0, 1, 2, 3, 4]. Hence, there are 4 intervalls. u=1.2 lies in the second intervall.\n\nModification of Algorithm A2.1 from 'The NURBS Book' p. 68.\n\nAssumption that the knotVector is open! (the first and last knot are repeated degree + 1 times)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.generateKnotVec-Tuple{Int64, Int64}","page":"API Reference","title":"NURBS.generateKnotVec","text":"generateKnotVec(b::Int, degree::Int)\n\nConvenience function to generate a knot vector for 'b' basis functions and a certain 'degree': \n\nThe first and last entry are repeated 'degree'+1 times. Normalized to [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.jacobian-Tuple{NURBS.Surface, Any, Any}","page":"API Reference","title":"NURBS.jacobian","text":"jacobian(Patch::Surface, uEvalpoints, vEvalpoints)\n\nCompute the Jacobian matrix and its (generalized) determinant at the parametric points 'uEvalpoints' and 'vEvalpoints'.\n\nReturn     - J     2-dimensional vector: first for the derivative w.r.t 'u', second w.r.t 'v'                 each vector entry contains a matrix of size (uEvalpoints, vEvalpoints)                 each entry of the matrix is an SVector with the derivatives: SVector(‚àÇx/‚àÇu, ‚àÇy/‚àÇu, ‚àÇy/‚àÇu)\n\n- dJ    matrix of size (uEvalpoints, vEvalpoints) where each entry is the Jacobi determinant evaluated at the points 'u' and 'v'.\n\nNote: surface points are evaluated but thrown away: maybe change this/make use of it.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.normalizationDerivative-Tuple{Any, Int64, Any, Real, Int64}","page":"API Reference","title":"NURBS.normalizationDerivative","text":"normalizationDerivative(knotVector, degree::Int, weights, u::Real, k::Int)\n\nReturn the k-th derivative of the weight function (21) in [2].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.numBasisFunctions-Tuple{NURBS.Basis}","page":"API Reference","title":"NURBS.numBasisFunctions","text":"numBasisFunctions(basis::Basis)\n\nThe number of basis functions is fixed by the knot vector and the degree.\n\nAssumption: the first and last knot vector entry has mulitplicity degree + 1.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaive-Tuple{Any, Int64, Int64, Any, Any}","page":"API Reference","title":"NURBS.nurbsNaive","text":"nurbsNaive(knotVector, i::Int, degree::Int, evalpoints, weights)\n\ni-th NURB basis function of degree 'degree', the 'knotVector', and with 'weights' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaive-Tuple{Any, Int64, Int64, Real, Any}","page":"API Reference","title":"NURBS.nurbsNaive","text":"nurbsNaive(knotVector, i::Int, degree::Int, u::Real, weights)\n\ni-th NURB basis function of degree 'degree', the 'knotVector', and with 'weights' evaluated at single point 'u'.\n\nFormula (4.2) of 'The NURBS Book' p. 118. \n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaive-Tuple{NURB, Int64, Any}","page":"API Reference","title":"NURBS.nurbsNaive","text":"nurbsNaive(basis::NURB, i::Int, evalpoints)\n\ni-th NURB basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaiveDerivative-Tuple{Any, Int64, Int64, Any, Any, Int64}","page":"API Reference","title":"NURBS.nurbsNaiveDerivative","text":"nurbsNaiveDerivative(knotVector, i::Int, degree::Int, weights, evalpoints, k::Int; normalize=true)\n\nCompute the k-th derivative of i-th NURBS basis function of degree 'degree' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaiveDerivative-Tuple{Any, Int64, Int64, Any, Real, Int64}","page":"API Reference","title":"NURBS.nurbsNaiveDerivative","text":"nurbsNaiveDerivative(knotVector, i::Int, degree::Int, weights, u::Real, k::Int)\n\nk-th derivative of the i-th NURBS basis function of degree 'degree' evaluated at (single) point 'u'.\n\nFormula (52) of [2].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaiveDerivative-Tuple{NURB, Int64, Int64, Any}","page":"API Reference","title":"NURBS.nurbsNaiveDerivative","text":"nurbsNaiveDerivative(basis::NURB, i::Int, k::Int, evalpoints)\n\nCompute the k-th derivative of i-th NURBS basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.parseCtrlPoints","page":"API Reference","title":"NURBS.parseCtrlPoints","text":"parseCtrlPoints(pointDims, stringVec, T=Float64)\n\nTake the 3 strings in 'stringVec' and parse it into a pointDims[1] x pointDims[2] matrix where each entry is a SVector for a controlpoint.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.parseLine","page":"API Reference","title":"NURBS.parseLine","text":"parseLine(line::String, T=Float64)\n\nTake the string 'line' of the form '0.1 0.2 0.6 ...' and parse it to a vector with eltype 'T'.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.parseSinglePatch-Tuple{Any, Int64, Any}","page":"API Reference","title":"NURBS.parseSinglePatch","text":"parseSinglePatch(stringVec, lineInd)\n\nTake the string vector and the line index where \"PATCH\" stands and extract the information of a single patch\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.readMultipatch","page":"API Reference","title":"NURBS.readMultipatch","text":"readMultipatch(filename::String)\n\nRead multipatch file organized as:\n\nPATCH a 4 4             -> degree in u and v 5 5             -> number of control points in u and v 0.0 0.0 ...     -> knot vector in u 0.0 0.0 ...     -> knot vector in v 0.1 0.2 ...     | 0.1 0.2 ...      > xyz components of the control points (normalized with the weigths -> we remove this weighting when reading in the data) 0.1 0.2 ...     | 1.0 1.0 ...     -> weights\n\nPATCH b  ...\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{BsplineSurface, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(Patch::BsplineSurface, uEvalpoints, vEvalpoints, k::Int)\n\nConvenience function to compute points of the k-th derivatives of a B-spline surface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, weights, k::Int)\n\nCompute NURBS surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nUsing (4.20) on page 136 of 'The NURBS Book'.\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\nReturns a (k x k) matrix where each entry is a matrix of size (uKnotVector x vKnotVector): surfaces[q, p] is the matrix for the (q-1)-th derivative in u-direction and the (p-1)-th derivative in v-direction.\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, k::Int)\n\nCompute B-spline surface and its derivatives: given the knotvectors and the degrees in 'u' and 'v' direction, the surface and its derivatives are evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\nReturns a (k x k) matrix where each entry is a matrix of size (uKnotVector x vKnotVector): surfaces[q, p] is the matrix for the (q-1)-th derivative in u-direction and the (p-1)-th derivative in v-direction.\n\nNote: not the most efficient implementation. TODO: implement algorithm A.37 and A.38 of 'The Nurbs book'\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{NURBSsurface, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(Patch::NURBSsurface, uEvalpoints, vEvalpoints, k::Int)\n\nConvenience function to compute points on a NURBSsurface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPointsUV-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Int64, Int64, Any, Any}","page":"API Reference","title":"NURBS.surfaceDerivativesPointsUV","text":"surfaceDerivativesPointsUV(uDegree::Int, vDegree::Int, controlPoints, uVector, vVector, Nu, Nv, q::Int, p::Int, uSpan, vSpan)\n\nCompute the q-th derivative along 'u' and the p-th derivative along 'v'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{BsplineSurface, Any, Any}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(Patch::BsplineSurface, uEvalpoints, vEvalpoints)\n\nConvenience function to compute points on a B-spline surface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Any}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, weights)\n\nCompute NURBS surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector)\n\nCompute B-spline surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{NURBSsurface, Any, Any}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(Patch::NURBSsurface, uEvalpoints, vEvalpoints)\n\nConvenience function to compute points on a NURBSsurface.\n\n\n\n\n\n","category":"method"},{"location":"basis/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"Two type of basis functions are available:","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"B-splines\nNURBS","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Both are defined by initializing corresponding structures. A naive evaluation method is available for both, an efficient evaluation only for B-splines.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Define-Structures","page":"Bases","title":"Define Structures","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"NURBS and B-spline bases are defined by initializing a Bspline or a NURB structure, respectively.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"using NURBS # hide\n# --- parameters\nb = 6       # number of basis functions\np = 2       # degree of NURBS\n\nw = ones(b) # weights for NURBS\nw[4] = 1.8\n\n# --- resulting knot vector\nkVec = generateKnotVec(b, p)\n\n# --- structures\nBspl = Bspline(p, kVec)\nNrbs = NURB(p, kVec, w)\nnothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Naive-Evaluation","page":"Bases","title":"Naive Evaluation","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"To evaluate the bases at certain points the bSplineNaive and the nurbsNaive functions are provided. For the derivatives the bSplineNaiveDerivative and the nurbsNaiveDerivative functions are provided.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"note: Note\nThe naive evaluation methods are solely implemented to play around with parameters (to get familiar with NURBS and B-splines). ","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"# --- define points where the bases are evaluated\nevalpoints = collect(0:0.001:1.0)\n\n# --- evaluate bases (4-th basis function)\nbspline = bSplineNaive(Bspl, 4, evalpoints) \nnurb    = nurbsNaive(Nrbs, 4, evalpoints)\n\n# --- evaluate derivatives (1st derivative of 4-th basis function)\nbsplineD = bSplineNaiveDerivative(Bspl, 4, 1, evalpoints) \nnurbD    = nurbsNaiveDerivative(Nrbs, 4, 1, evalpoints)\n\n\nusing Plots\nplotly()\n\nPlots.plot(evalpoints, bspline, w=2, \n    label=\"B-spline\", \n    title=\"4-th basis function\", \n    xlabel=\"ùë¢\", \n    ylabel=\"ùëÅ‚ÇÑ,‚ÇÇ(ùë¢)\")\nPlots.plot!(evalpoints, nurb, w=2, label=\"NURB\")\nxlims!(0, 1) # hide\nylims!(0, 1) # hide\nsavefig(\"plotBspl.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"plotBspl.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Plots.plot(evalpoints, bsplineD, w=2, \n    label=\"B-spline\", \n    title=\"1st derivative of 4-th basis function\", \n    xlabel=\"ùë¢\", \n    ylabel=\"‚àÇ·µ§ ùëÅ‚ÇÑ,‚ÇÇ(ùë¢)\")\nPlots.plot!(evalpoints, nurbD, w=2, label=\"NURB\")\nxlims!(0, 1) # hide\nsavefig(\"plotBsplD.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"plotBsplD.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Efficient-Evaluation","page":"Bases","title":"Efficient Evaluation","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"For the B-splines the efficient evaluation of [2] is implemented via bSpline and bSplineDerivatives. That is, only the basis functions different from zero are evaluated:","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"note: Note\nFor the evaluation of NURBS curves and surfaces (and their derivatives) the B-spline evaluation is sufficient.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"bspline  = bSpline(Bspl, evalpoints)\nbsplineD = bSplineDerivatives(Bspl, 1, evalpoints)\n\nPlots.plot(evalpoints, bspline, w=2, \n    leg=false, \n    title=\"all basis functions\", \n    xlabel=\"ùë¢\", \n    ylabel=\"ùëÅ·µ¢,‚ÇÇ(ùë¢)\")\nxlims!(0, 1) # hide\nylims!(0, 1) # hide\nsavefig(\"plotBspleff.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"plotBspleff.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Plots.plot(evalpoints, bsplineD[:, 2, :], w=2, \n    leg=false,\n    title=\"1st derivative of all basis functions\", \n    xlabel=\"ùë¢\", \n    ylabel=\"‚àÇ·µ§ ùëÅ·µ¢,‚ÇÇ(ùë¢)\")\nxlims!(0, 1) # hide\nsavefig(\"plotBsplDeff.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"plotBsplDeff.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the main branch. Before doing so please: ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(NURBS))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"NURBS\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For more detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"NURBS\"; coverage=true, julia_args=`--threads 4`)\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(NURBS) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"NURBS.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the SphericalScattering.lcov.info file in the settings.","category":"page"},{"location":"#NURBS.jl","page":"Introduction","title":"NURBS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides B-spline and NURBS basis functions, their derivatives, as well as curves and surfaces based on both considered basis functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following aspects are implemented (‚úì) and planned (‚åõ):","category":"page"},{"location":"#B-spline-and-NURBS","page":"Introduction","title":"B-spline & NURBS","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"‚úì Basis & derivatives\n‚úì Curves & derivatives\n‚úì Surfaces & derivatives","category":"page"},{"location":"#Fundamental-operations","page":"Introduction","title":"Fundamental operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"‚úì File I/O (basic)\n‚åõ Knot insertion / removal\n‚åõ Degree elevation / reduction\n‚åõ Construction of common geometries","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Basically, chapters 2-4 of [2] are implemented so far.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nOpen knot vectors are assumed everywhere, if not stated otherwise.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThe parametric space is assumed to be [0, 1] everywhere.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Installing NURBS is done by entering the package manager (enter ] at the julia REPL) and issuing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add NURBS ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#refs","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The implementation is based on","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1] L. Piegl, The NURBS Book, Berlin Heidelberg, Springer-Verlag, 1997.\n[2] R.N. Simpson, et. al, A Two-Dimensional Isogeometric Boundary Element Method for Elastostatic Analysis, Comput. Methods Appl. Mech. Engrg., 2012.","category":"page"},{"location":"surfaces/#Surfaces","page":"Surfaces","title":"Surfaces","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Two type of surfaces are available:","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"B-splines surfaces\nNURBS surfaces","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Both are defined by initializing corresponding structures.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Define-Structures","page":"Surfaces","title":"Define Structures","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"NURBS and B-spline surfaces are defined by initializing a BsplineSurface or a NURBSsurface structure, respectively.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using NURBS # hide\nusing StaticArrays\n\n# --- parameters\nkVec = Float64[0, 0, 0, 1, 2, 3, 4, 5, 5, 5] # knot vector\nkVec ./= maximum(kVec)                       # normalize it\n\np = 2 # degree of the basis\n\n# --- control points\ncontrolPoints = [[SVector(0.0,0.0,3.0), SVector(0.0,1.0,3.0), SVector(0.0,2.0,2.0), SVector(0.0,3.0,2.0), SVector(0.0,4.0,2.0), SVector(0.0,5.0,2.0), SVector(0.0,6.0,2.0)],\n                 [SVector(1.0,0.0,3.0), SVector(1.0,1.0,3.0), SVector(1.0,2.0,2.0), SVector(1.0,3.0,2.0), SVector(1.0,4.0,2.0), SVector(1.0,5.0,2.0), SVector(1.0,6.0,2.0)],\n                 [SVector(2.0,0.0,2.0), SVector(2.0,1.0,2.0), SVector(2.0,2.0,1.0), SVector(2.0,3.0,1.0), SVector(2.0,4.0,1.0), SVector(2.0,5.0,1.0), SVector(2.0,6.0,1.0)],\n                 [SVector(3.0,0.0,2.0), SVector(3.0,1.0,2.0), SVector(3.0,2.0,1.0), SVector(3.0,3.0,1.0), SVector(3.0,4.0,1.0), SVector(3.0,5.0,0.0), SVector(3.0,7.0,0.0)],\n                 [SVector(4.0,0.0,1.0), SVector(4.0,1.0,1.0), SVector(4.0,2.0,0.0), SVector(4.0,3.0,0.0), SVector(4.0,4.0,1.0), SVector(4.0,5.0,0.0), SVector(4.0,6.0,0.0)],\n                 [SVector(5.0,0.0,1.0), SVector(5.0,1.0,1.0), SVector(5.0,2.0,0.0), SVector(5.0,3.0,0.0), SVector(5.0,4.0,0.0), SVector(5.0,5.0,0.0), SVector(5.0,6.0,0.0)],\n                 [SVector(6.0,0.0,1.0), SVector(6.0,1.0,1.0), SVector(6.0,2.0,0.0), SVector(6.0,3.0,0.0), SVector(6.0,4.0,0.0), SVector(6.0,5.0,0.0), SVector(6.0,6.0,0.0)]]\n\ncontrolPoints = [controlPoints[i][j] for i in 1:7, j in 1:7]\n\n# --- weights for the NURBS basis\nw = ones(size(controlPoints)) \nw[5,5] = 2.0\nw[7,2] = 0.8\n\n# --- initialize structures (using the same basis in both parametric directions)\nPatchB = BsplineSurface(Bspline(p, kVec), Bspline(p, kVec), controlPoints) \nPatchN = NURBSsurface(Bspline(p, kVec), Bspline(p, kVec), controlPoints, w)\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Evaluate-Points-on-the-Surface","page":"Surfaces","title":"Evaluate Points on the Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To evaluate the surfaces at parametric points the surfacePoints function is provided. ","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nSBspline = surfacePoints(PatchB, uEvalpoints, vEvalpoints)\nSNurbs   = surfacePoints(PatchN, uEvalpoints, vEvalpoints)\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To plot the surfaces the plotSurface or the plotPatches functions are provided, where the latter evaluates the surface points itself.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"note: Note\nThe PlotlyJS.jl package has to be loaded in order to make the functions available. Reason is the employed Requires.jl framework.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using PlotlyJS\n\nplotSurface(SNurbs, controlPoints=controlPoints)\nt = plotSurface(SNurbs, controlPoints=controlPoints, enforceRatio=false) # hide\nsavefig(t, \"surface3D.html\"); nothing # hide\n\n# alternatively\nplotPatches([PatchN], plotControlPoints=true)","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"surface3D.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Evaluate-Derivatives-of-the-Surface","page":"Surfaces","title":"Evaluate Derivatives of the Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To evaluate derivatives of surfaces at parametric points the surfaceDerivativesPoints function is provided.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nS = surfaceDerivativesPoints(PatchN, uEvalpoints, vEvalpoints, 2) # 0-th, 1st, and 2nd derivatives\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"The plotSurface function has an optional argument tangents to plot vectors at the points of the curve.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using PlotlyJS\n\nplotSurface(S[1, 1], tangents=S[2,1], controlPoints=PatchN.controlPoints, enforceRatio=false)\nt = plotSurface(S[1, 1], tangents=S[2,1], controlPoints=PatchN.controlPoints, enforceRatio=false) # hide\nsavefig(t, \"surface3Dder.html\"); nothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"surface3Dder.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"For convenince the following utils are provided.","category":"page"},{"location":"utils/#File-I/O","page":"Utils","title":"File I/O","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"To read multipatch files as defined and provided by the nurbs Octave implementation and BEMBEL a function readMultipatch is provided.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"note: Note\nApart from these files the implementation in this package is done independendly from the Octave package. Similarities are accidentally (as it is also based on [2]). Also note, that the Octave package so far provides more functionality.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"using NURBS # hide\nPatches = readMultipatch(\"assets/sphere.dat\")\n\nusing PlotlyJS\nplotPatches(Patches, plotControlPoints=true, resolution=0.1)\nt = plotPatches(Patches, plotControlPoints=true, resolution=0.1) # hide\nsavefig(t, \"sphere.html\"); nothing # hide","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"<object data=\"sphere.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"utils/#Jacobian","page":"Utils","title":"Jacobian","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"To compute the Jacobian matrix and its generalized determinant a function jacobian is provided.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nJ, dJ = jacobian(Patches[1], uEvalpoints, vEvalpoints)\nnothing # hide","category":"page"}]
}
