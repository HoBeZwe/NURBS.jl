var documenterSearchIndex = {"docs":
[{"location":"curves/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Two type of curves are available:","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"B-splines curves\nNURBS curves","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Both are defined by initializing corresponding structures.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Define-Structures","page":"Curves","title":"Define Structures","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"NURBS and B-spline curves are defined by initializing a BsplineCurve or a NURBScurve structure, respectively.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using NURBS # hide\n# --- parameters\nkVec = Float64[0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 6, 6] # knot vector\nkVec ./= maximum(kVec)                                # normalize it\n\np = 3  # degree \n\n# --- control points\nusing StaticArrays\nP1 = SVector(0.0, 0.0, 0.0)\nP2 = SVector(0.1, 0.25, 0.0)\nP3 = SVector(0.25, 0.3, 0.0)\nP4 = SVector(0.3, 0.5, 0.0)\nP5 = SVector(0.4, 0.4, 0.0)\nP6 = SVector(0.6, 0.3, 0.0)\nP7 = SVector(0.8, 0.7, 1.0)\nP8 = SVector(1.0, 0.4, 0.0)\nP9 = SVector(1.1, 0.4, 0.0)\n\ncontrolPoints = [P1 , P2 , P3 , P4 , P5 , P6 , P7 , P8 , P9 ]\nw             = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 3.0, 1.0, 1.0] # weights for the NURBS\n\n# --- the structures\nNBspline = BsplineCurve(Bspline(p, kVec), controlPoints)\nNNurbs   = NURBScurve(NURB(p, kVec, w), controlPoints)\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Evaluate-Points-on-the-Curve","page":"Curves","title":"Evaluate Points on the Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"To evaluate the curves at parametric points simply hand over the latter. ","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"evalpoints = collect(0:0.0005:1.0)\n\nCBspline = NBspline(evalpoints)\nCNurbs   = NNurbs(evalpoints)\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"To plot the curves the plotCurve3D and the plotCurve functions are provided, where the latter ignores any 'z'-components.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"note: Note\nThe PlotlyJS.jl package has to be loaded in order to make the functions available. Reason is the employed Requires.jl framework.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using PlotlyJS\n\nplotCurve3D(CBspline, controlPoints=controlPoints)\nt = plotCurve3D(CBspline, controlPoints=controlPoints) # hide\nsavefig(t, \"cruve3D.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3D.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Evaluate-Derivatives-of-the-Curve","page":"Curves","title":"Evaluate Derivatives of the Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"To evaluate derivatives of curves at parametric points hand over the latter and the maximum derivative to be evaluated.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"evalpoints = collect(0:0.0005:1.0)\n\nC = NNurbs(evalpoints, 2) # 0-th, 1st, and 2nd derivatives\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"The plotCurve3D function has an optional argument tangents to plot vectors at the points of the curve.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using PlotlyJS\n\nplotCurve3D(C[1], controlPoints=controlPoints, tangents=C[2])\nt = plotCurve3D(C[1], controlPoints=controlPoints, tangents=C[2]) # hide\nsavefig(t, \"cruve3Dder.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3Dder.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/","page":"API Reference","title":"API Reference","text":"Modules = [NURBS]","category":"page"},{"location":"apiref/#NURBS.Bspline","page":"API Reference","title":"NURBS.Bspline","text":"Bspline{F} <: Basis{F}\n\nB-spline basis.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.Bspline-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.Bspline","text":"(basis::Bspline)(evalpoints, k::Int)\n\nEvaluate k-the derivative of B-spline basis at all evalpoints (all basis functions different from 0 at the evalpoints are evaluated).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.Bspline-Tuple{Any}","page":"API Reference","title":"NURBS.Bspline","text":"(basis::Bspline)(evalpoints)\n\nEvaluate B-spline basis at all evalpoints.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineCurve","page":"API Reference","title":"NURBS.BsplineCurve","text":"BsplineCurve{F} <: Curve{F}\n\nB-spline curve defined by the basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.BsplineCurve-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.BsplineCurve","text":"(curve::BsplineCurve)(uVector, k::Int)\n\nConvenience function to compute points on all k derivatives of a B-spline curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineCurve-Tuple{Any}","page":"API Reference","title":"NURBS.BsplineCurve","text":"(curve::BsplineCurve)(uVector)\n\nConvenience function to compute points on a B-spline curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineSurface","page":"API Reference","title":"NURBS.BsplineSurface","text":"BsplineSurface{F} <: Surface{F}\n\nSurface defined by a B-spline basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.BsplineSurface-Tuple{Any, Any, Int64}","page":"API Reference","title":"NURBS.BsplineSurface","text":"(Patch::BsplineSurface)(uEvalpoints, vEvalpoints, k::Int)\n\nConvenience function to compute points on all k derivatives of a B-spline surface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineSurface-Tuple{Any, Any}","page":"API Reference","title":"NURBS.BsplineSurface","text":"(Patch::BsplineSurface)(uEvalpoints, vEvalpoints)\n\nConvenience function to compute points on a B-spline surface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURB","page":"API Reference","title":"NURBS.NURB","text":"NURB{F} <: Basis{F}\n\nNURBS basis.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBScurve","page":"API Reference","title":"NURBS.NURBScurve","text":"NURBScurve{F} <: Curve{F}\n\nB-spline curve defined by the basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBScurve-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.NURBScurve","text":"(curve::NURBScurve)(uVector, k::Int)\n\nConvenience function to compute points on all k derivatives of a NURBS curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURBScurve-Tuple{Any}","page":"API Reference","title":"NURBS.NURBScurve","text":"(curve::NURBScurve)(uVector)\n\nConvenience function to compute points on a NURBS curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURBSsurface","page":"API Reference","title":"NURBS.NURBSsurface","text":"NURBSsurface{F} <: Surface{F}\n\nSurface defined by a B-spline basis, the control points, and the weights.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBSsurface-Tuple{Any, Any, Int64}","page":"API Reference","title":"NURBS.NURBSsurface","text":"(Patch::NURBSsurface)(uEvalpoints, vEvalpoints, k::Int)\n\nConvenience function to compute points on all k derivatives of a NURBSsurface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURBSsurface-Tuple{Any, Any}","page":"API Reference","title":"NURBS.NURBSsurface","text":"(Patch::NURBSsurface)(uEvalpoints, vEvalpoints)\n\nConvenience function to compute points on a NURBSsurface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.Jacobian-Tuple{Surface, Any, Any}","page":"API Reference","title":"NURBS.Jacobian","text":"Jacobian(Patch::Surface, uEvalpoints, vEvalpoints)\n\nCompute the Jacobian matrix and its (generalized) determinant at the parametric points 'uEvalpoints' and 'vEvalpoints'.\n\nReturn     - J     2-dimensional vector: first for the derivative w.r.t 'u', second w.r.t 'v'                 each vector entry contains a matrix of size (uEvalpoints, vEvalpoints)                 each entry of the matrix is an SVector with the derivatives: SVector(‚àÇx/‚àÇu, ‚àÇy/‚àÇu, ‚àÇy/‚àÇu)\n\n- dJ    matrix of size (uEvalpoints, vEvalpoints) where each entry is the Jacobi determinant evaluated at the points 'u' and 'v'.\n\nNote: surface points are evaluated but thrown away: maybe change this/make use of it.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Int64, Any}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, degree::Int, evalpoints; normalize=true)\n\ni-th b-spline basis function of degree 'degree' evaluated at all 'evalpoints'.\n\nThe knotvector is assumed to be normalized to [1, 0].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Int64, Real}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, degree::Int, u::Real)\n\ni-th b-spline basis function of degree 'degree' evaluated at u.\n\nFormula (2.5) of 'The NURBS Book' p. 50.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Real}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, u::Real)\n\ni-th b-spline basis function of degree 0 evaluated at u.\n\nFormula (2.5) of 'The NURBS Book' p. 50.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaiveDerivative-Tuple{Any, Int64, Int64, Any, Int64}","page":"API Reference","title":"NURBS.bSplineNaiveDerivative","text":"bSplineNaiveDer(knotVector, i::Int, degree::Int, evalpoints, k::Int; normalize=true)\n\nCompute the k-th derivative of i-th b-spline basis function of degree 'degree' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaiveDerivative-Tuple{Any, Int64, Int64, Real, Int64}","page":"API Reference","title":"NURBS.bSplineNaiveDerivative","text":"bSplineNaiveDerivative(knotVector, i::Int, degree::Int, u::Real, k::Int)\n\nk-th derivative of the i-th b-spline basis function of degree 'degree' evaluated at (single) point 'u'.\n\nFormula (2.9) of 'The NURBS Book' p. 61. (Recursive implementation to avoid the faculties in the (2.10) formula.)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.basisFun-Tuple{Any, Any, Int64, Any}","page":"API Reference","title":"NURBS.basisFun","text":"basisFun(knotSpan, uVector, degree::Int, knotVector)\n\nCompute the nonvanishing B-spline basis functions of degree 'degree' at the parametric points defined by 'uVector'\n\nReturn the B-spline basis functions vector of size length(uVector) * (degree + 1).\n\nAdapted from Algorithm A2.2 from 'The NURBS Book' p. 70.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{Int64, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curveDerivativesPoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector, weights, k::Int)\n\nCompute points on the k-th derivatives of a NURBS curve: given the 'knotVector', the 'controlPoints', the 'degree', and the 'weights', the curve is evaluated at the points given in 'uVector'.\n\nUsing (4.8) on page 125 of 'The NURBS Book'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{Int64, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector)\n\nCompute a points on the k-th derivatives of a B-spline curve: given the 'knotVector', the 'controlPoints', and the 'degree', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{Int64, Any, Any, Any}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector)\n\nCompute a 1D B-spline curve: given the 'knotVector', the 'controlPoints', and the 'degree', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{Int64, Vararg{Any, 4}}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector, weights)\n\nCompute points on a NURBS curve: given the 'knotVector', the 'controlPoints', the 'degree', and the 'weights', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.derBasisFun-Tuple{Any, Int64, Any, Any, Int64}","page":"API Reference","title":"NURBS.derBasisFun","text":"derBasisFun(knotSpan, degree::Int, evalpoints, knotVector, numberDerivatives::Int)\n\nCompute the nonvanishing B-spline basis functions and its derivatives of degree 'degree' at the parametric points defined by 'uVector'.\n\nOrganization of output:  dersv[n, k, :] contains (k-1)-th derivative at n-th point.\n\nAdapted from Algorithm A2.3 from 'The NURBS BOOK' p. 72.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaive-Tuple{Bspline, Int64, Any}","page":"API Reference","title":"NURBS.evalNaive","text":"evalNaive(basis::Bspline, i::Int, evalpoints)\n\ni-th B-spline basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaive-Tuple{NURB, Int64, Any}","page":"API Reference","title":"NURBS.evalNaive","text":"evalNaive(basis::NURB, i::Int, evalpoints)\n\ni-th NURB basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaiveDerivative-Tuple{Bspline, Int64, Int64, Any}","page":"API Reference","title":"NURBS.evalNaiveDerivative","text":"evalNaiveDerivative(basis::Bspline, i::Int, k::Int, evalpoints)\n\nCompute the k-th derivative of i-th b-spline basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaiveDerivative-Tuple{NURB, Int64, Int64, Any}","page":"API Reference","title":"NURBS.evalNaiveDerivative","text":"evalNaiveDerivative(basis::NURB, i::Int, k::Int, evalpoints)\n\nCompute the k-th derivative of i-th NURBS basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.extendControlPoints!-Tuple{Any, Any, Int64, Int64, Real, Int64, Int64, Any}","page":"API Reference","title":"NURBS.extendControlPoints!","text":"extendControlPoints!(controlPoints, knotVecOrig, degree::Int, pos::Int, uNew::Real, multiplicity::Int, oldMult::Int, weights)\n\nInsert the new control points (and optionally the weights) corresponding to the new values in the knot vector.\n\nAdaption of Algorithm A5.1 from 'The NURBS Book' p. 151.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.extendKnotVector!-Tuple{Any, Int64, Real, Int64}","page":"API Reference","title":"NURBS.extendKnotVector!","text":"extendKnotVector!(knotVecOrig, newParametricPoint::Real, multiplicity::Int)\n\nInsert the new value with a given mulitplicity (insert the point multiple times).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.findSpan-Tuple{Int64, Any, Any}","page":"API Reference","title":"NURBS.findSpan","text":"findSpan(n::Int, u, knotVector)\n\nFind the spans of a B-spline knot vector at the parametric points 'u', where 'b' is the number of basis functions (control points).\n\nSpan: the intervall index in which a point lies. E.g., knotVector = [0, 1, 2, 3, 4]. Hence, there are 4 intervalls. u=1.2 lies in the second intervall.\n\nModification of Algorithm A2.1 from 'The NURBS Book' p. 68.\n\nAssumption that the knotVector is open! (the first and last knot are repeated degree + 1 times)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.generateKnotVec-Tuple{Int64, Int64}","page":"API Reference","title":"NURBS.generateKnotVec","text":"generateKnotVec(b::Int, degree::Int)\n\nConvenience function to generate a knot vector for 'b' basis functions and a certain 'degree': \n\nThe first and last entry are repeated 'degree'+1 times. Normalized to [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.insertKnot","page":"API Reference","title":"NURBS.insertKnot","text":"insertKnot(knotVecOrig, controlPointsOrig, p::Int, newParametricPoint::Real, multiplicity::Int)\n\nInsert a new value with a given mulitplicity (insert the value multiple times) into a knot vector for the polynomial degree 'degree'. Return the resutling knot vector and the new control points.\n\nAdaption of Algorithm A5.1 from 'The NURBS Book' p. 151.\n\nThe provided knot vector and control-point vector are NOT modified.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.insertKnot!","page":"API Reference","title":"NURBS.insertKnot!","text":"insertKnot!(knotVecOrig, controlPointsOrig, p::Int, newParametricPoint::Real, multiplicity::Int)\n\nInsert a new value with a given mulitplicity (insert the value multiple times) into a knot vector for the polynomial degree 'degree'. Return the resutling knot vector and the new control points.\n\nAdaption of Algorithm A5.1 from 'The NURBS Book' p. 151.\n\nThe provided knot vector and control-point vector are modified.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.isValidKnotVector!-Tuple{Any}","page":"API Reference","title":"NURBS.isValidKnotVector!","text":"isValidKnotVector!(kVec)\n\nCheck whether the knot vector has only entries in [0, 1] and is in ascending order.\n\nIf not the knot vector is modified.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.normalizationDerivative-Tuple{Any, Int64, Any, Real, Int64}","page":"API Reference","title":"NURBS.normalizationDerivative","text":"normalizationDerivative(knotVector, degree::Int, weights, u::Real, k::Int)\n\nReturn the k-th derivative of the weight function (21) in [2].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.numBasisFunctions-Tuple{NURBS.Basis}","page":"API Reference","title":"NURBS.numBasisFunctions","text":"numBasisFunctions(basis::Basis)\n\nThe number of basis functions is fixed by the knot vector and the degree.\n\nAssumption: the first and last knot vector entry has mulitplicity degree + 1.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaive-Tuple{Any, Int64, Int64, Any, Any}","page":"API Reference","title":"NURBS.nurbsNaive","text":"nurbsNaive(knotVector, i::Int, degree::Int, evalpoints, weights)\n\ni-th NURB basis function of degree 'degree', the 'knotVector', and with 'weights' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaive-Tuple{Any, Int64, Int64, Real, Any}","page":"API Reference","title":"NURBS.nurbsNaive","text":"nurbsNaive(knotVector, i::Int, degree::Int, u::Real, weights)\n\ni-th NURB basis function of degree 'degree', the 'knotVector', and with 'weights' evaluated at single point 'u'.\n\nFormula (4.2) of 'The NURBS Book' p. 118. \n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaiveDerivative-Tuple{Any, Int64, Int64, Any, Any, Int64}","page":"API Reference","title":"NURBS.nurbsNaiveDerivative","text":"nurbsNaiveDerivative(knotVector, i::Int, degree::Int, weights, evalpoints, k::Int; normalize=true)\n\nCompute the k-th derivative of i-th NURBS basis function of degree 'degree' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaiveDerivative-Tuple{Any, Int64, Int64, Any, Real, Int64}","page":"API Reference","title":"NURBS.nurbsNaiveDerivative","text":"nurbsNaiveDerivative(knotVector, i::Int, degree::Int, weights, u::Real, k::Int)\n\nk-th derivative of the i-th NURBS basis function of degree 'degree' evaluated at (single) point 'u'.\n\nFormula (52) of [2].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.parseCtrlPoints","page":"API Reference","title":"NURBS.parseCtrlPoints","text":"parseCtrlPoints(pointDims, stringVec, T=Float64)\n\nTake the 3 strings in 'stringVec' and parse it into a pointDims[1] x pointDims[2] matrix where each entry is a SVector for a controlpoint.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.parseLine","page":"API Reference","title":"NURBS.parseLine","text":"parseLine(line::String, T=Float64)\n\nTake the string 'line' of the form '0.1 0.2 0.6 ...' and parse it to a vector with eltype 'T'.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.parseSinglePatch-Tuple{Any, Int64, Any}","page":"API Reference","title":"NURBS.parseSinglePatch","text":"parseSinglePatch(stringVec, lineInd)\n\nTake the string vector and the line index where \"PATCH\" stands and extract the information of a single patch\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.readMultipatch","page":"API Reference","title":"NURBS.readMultipatch","text":"readMultipatch(filename::String)\n\nRead multipatch file organized as:\n\nPATCH a 4 4             -> degree in u and v 5 5             -> number of control points in u and v 0.0 0.0 ...     -> knot vector in u 0.0 0.0 ...     -> knot vector in v 0.1 0.2 ...     | 0.1 0.2 ...      > xyz components of the control points (normalized with the weigths -> we remove this weighting when reading in the data) 0.1 0.2 ...     | 1.0 1.0 ...     -> weights\n\nPATCH b  ...\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.spanRanges-Tuple{Bspline, Any}","page":"API Reference","title":"NURBS.spanRanges","text":"spanRanges(Bspl::Bspline, points)\n\nDetermine the ranges of the points which lie in each span of the B-spline (assuming normalized open knot vectors).\n\nReturn a vector of ranges (one entry per span).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, weights, k::Int)\n\nCompute NURBS surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nUsing (4.20) on page 136 of 'The NURBS Book'.\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\nReturns a (k x k) matrix where each entry is a matrix of size (uKnotVector x vKnotVector): surfaces[q, p] is the matrix for the (q-1)-th derivative in u-direction and the (p-1)-th derivative in v-direction.\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, k::Int)\n\nCompute B-spline surface and its derivatives: given the knotvectors and the degrees in 'u' and 'v' direction, the surface and its derivatives are evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\nReturns a (k x k) matrix where each entry is a matrix of size (uKnotVector x vKnotVector): surfaces[q, p] is the matrix for the (q-1)-th derivative in u-direction and the (p-1)-th derivative in v-direction.\n\nNote: not the most efficient implementation. TODO: implement algorithm A.37 and A.38 of 'The Nurbs book'\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPointsUV-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Int64, Int64, Any, Any}","page":"API Reference","title":"NURBS.surfaceDerivativesPointsUV","text":"surfaceDerivativesPointsUV(uDegree::Int, vDegree::Int, controlPoints, uVector, vVector, Nu, Nv, q::Int, p::Int, uSpan, vSpan)\n\nCompute the q-th derivative along 'u' and the p-th derivative along 'v'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{Int64, Int64, Vararg{Any, 5}}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector)\n\nCompute B-spline surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{Int64, Int64, Vararg{Any, 6}}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, weights)\n\nCompute NURBS surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ‚Äì‚Äì- P12 ‚Äì‚Äì- P13 ‚Äì-> y / v direction |          |         | |          |         | P21 ‚Äì‚Äì- P22 ‚Äì‚Äì- P23 |          |         | |          |         | P31 ‚Äì‚Äì- P32 ‚Äì‚Äì- P_33 | x / u direction\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the main branch. Before doing so please: ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(NURBS))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"NURBS\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For more detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"NURBS\"; coverage=true, julia_args=`--threads 4`)\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(NURBS) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"NURBS.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the SphericalScattering.lcov.info file in the settings.","category":"page"},{"location":"degreeElevation/#Degree-Elevation","page":"Degree Elevation","title":"Degree Elevation","text":"","category":"section"},{"location":"degreeElevation/","page":"Degree Elevation","title":"Degree Elevation","text":"To be done.","category":"page"},{"location":"basis/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"The considered B-spline and NURBS basis functions are defined by initializing corresponding structures. A naive evaluation method is available for both, an efficient evaluation only for B-splines.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Define-Structures","page":"Bases","title":"Define Structures","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"NURBS and B-spline bases are defined by initializing a Bspline or a NURB structure, respectively.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"using NURBS # hide\n# --- parameters\nb = 6       # number of basis functions\np = 2       # degree of NURBS\n\nw = ones(b) # weights for NURBS\nw[4] = 1.8\n\n# --- resulting knot vector\nkVec = generateKnotVec(b, p)\n\n# --- structures\nBspl = Bspline(p, kVec)\nNrbs = NURB(p, kVec, w)\nnothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Naive-Evaluation","page":"Bases","title":"Naive Evaluation","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"To evaluate the bases at certain points the evalNaive function is provided.  It directly implemens the defining equations of the B-splines and NURBS. For the derivatives the evalNaiveDerivative function is provided derectly implementing the defining equations of the derivatives.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"note: Note\nThe naive evaluation methods are solely implemented to play around with parameters (to get familiar with NURBS and B-splines). ","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"# --- define points where the bases are evaluated\nevalpoints = collect(0:0.001:1.0)\n\n# --- evaluate bases (4-th basis function)\nbspline = evalNaive(Bspl, 4, evalpoints) \nnurb    = evalNaive(Nrbs, 4, evalpoints)\n\n# --- evaluate derivatives (1st derivative of 4-th basis function)\nbsplineD = evalNaiveDerivative(Bspl, 4, 1, evalpoints) \nnurbD    = evalNaiveDerivative(Nrbs, 4, 1, evalpoints)\n\n\nusing Plots\nplotly()\n\nPlots.plot(evalpoints, bspline, w=2, \n    label=\"B-spline\", \n    title=\"4-th basis function\", \n    xlabel=\"ùë¢\", \n    ylabel=\"ùëÅ‚ÇÑ,‚ÇÇ(ùë¢)\")\nPlots.plot!(evalpoints, nurb, w=2, label=\"NURB\")\nxlims!(0, 1) # hide\nylims!(0, 1) # hide\nsavefig(\"plotBspl.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBspl.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Plots.plot(evalpoints, bsplineD, w=2, \n    label=\"B-spline\", \n    title=\"1st derivative of 4-th basis function\", \n    xlabel=\"ùë¢\", \n    ylabel=\"‚àÇ·µ§ ùëÅ‚ÇÑ,‚ÇÇ(ùë¢)\")\nPlots.plot!(evalpoints, nurbD, w=2, label=\"NURB\")\nxlims!(0, 1) # hide\nsavefig(\"plotBsplD.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBsplD.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Efficient-Evaluation","page":"Bases","title":"Efficient Evaluation","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"For the B-splines the efficient evaluation of [1] is implemented by handing evaluation points to the Bspline structure and optionally as second argument the maximum derivative that shall be computed. That is, only the basis functions different from zero are evaluated:","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"note: Note\nFor the evaluation of NURBS curves and surfaces (and their derivatives) the B-spline evaluation is sufficient.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"bspline  = Bspl(evalpoints)\nbsplineD = Bspl(evalpoints, 2) # 0th, 1st, and 2nd derivative\n\n\nPlots.plot(evalpoints, bspline, w=2, \n    leg=false, \n    title=\"all basis functions\", \n    xlabel=\"ùë¢\", \n    ylabel=\"ùëÅ·µ¢,‚ÇÇ(ùë¢)\")\nxlims!(0, 1) # hide\nylims!(0, 1) # hide\nsavefig(\"plotBspleff.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBspleff.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Plots.plot(evalpoints, bsplineD[:, 2, :], w=2, \n    leg=false,\n    title=\"1st derivative of all basis functions\", \n    xlabel=\"ùë¢\", \n    ylabel=\"‚àÇ·µ§ ùëÅ·µ¢,‚ÇÇ(ùë¢)\")\nxlims!(0, 1) # hide\nsavefig(\"plotBsplDeff.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBsplDeff.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis_def/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The two considered B-spline and NURBS basis functions are based on a knot vector.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis_def/#kvec","page":"Bases","title":"Knot Vectors","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"Given a polynomial degree p in 1 2 3 dots, a knot vector of length M is defined as ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"U = u_1 dots u_M","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"where u_i leq u_i+1, i.e., the entries are sorted in ascending order, u_1 = 0, u_M = 1, and the first and last entry are each repeated p + 1 times.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"note: Note\nThis specific definition of the first and last entries defines an open knot vector; the only type of knot vector considered in this package.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"note: Note\nHaving u_i in 0 1 is assumed (and partially enforced) everywhere. ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis_def/#Definitions","page":"Bases","title":"Definitions","text":"","category":"section"},{"location":"basis_def/#bspl","page":"Bases","title":"B-Splines","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The B-spline basis functions of degree p are defined as N_ip on the knot vector U recursively, starting with the piecewise constant (p=0) [1, p. 50]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"N_i0(u) = begincases 1  u_i leq u  u_i+1  0  textotherwiseendcases","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"as well as for p0","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"N_ip(u) = cfracu - u_iu_i+p - u_i  N_i p-1(u) + cfracu_i+p+1 - uu_i+p+1 - u_i+1  N_i+1 p-1(u) ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"Whenever one of the contained quotients exhibits a division by 0, the quotient is defined to be 0 itself.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"note: Note\nThe number of basis functions B is related to the length of the knot vector M and the polynomial degree p asB = M - p - 1 ","category":"page"},{"location":"basis_def/#nurbs","page":"Bases","title":"NURBS","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"Introducing B weights w_i in mathbbR_+ the rational B-spline basis functions [1, p. 118]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"R_i p(u) = cfracN_i p(u) w_isum_j=1^B N_j p(u) w_i","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"are defined based on the B-spline basis N_i p on the knot vector U.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis_def/#derB","page":"Bases","title":"Derivatives","text":"","category":"section"},{"location":"basis_def/#B-Splines","page":"Bases","title":"B-Splines","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The k-th derivative of the B-splines N_i p can be computed as [1, p. 61]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"N_ip^(k)(u) = p left( cfracN_ip-1^(k-1)u_i+p - u_i - cfracN_i+1p-1^(k-1)u_i+p+1 - u_i+1 right) ","category":"page"},{"location":"basis_def/#NURBS","page":"Bases","title":"NURBS","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The k-th derivative of the NURBS basis functions R_i p can be computed as [2]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"R_ip^(k)(u) = cfracw_i  N_ip^(k)(u) - sum_j=1^k beginpmatrix k jendpmatrix W^(j)(u) R_ip^k-j(u)W^(0)(u)","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"with","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"W^(k)(u) = sum_i=1^B N_i p^(k)(u) w_i ","category":"page"},{"location":"surfaces_def/#Surfaces","page":"Surfaces","title":"Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"Based on both bases surfaces are defined.","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces_def/#Definitions","page":"Surfaces","title":"Definitions","text":"","category":"section"},{"location":"surfaces_def/#B-Spline-Surfaces","page":"Surfaces","title":"B-Spline Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"A tensor product surface [1, p. 100] ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms(uv) = sum_i=1^B_u sum_j=1^B_v N_ip(u) N_jq(v) bmp_ij","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"is defined by introducing two knot-vectors for the B-splines of degree p and q and a second parametric value v in 0 1, as well as a net of constant controlpoints bmp_ij in mathbbR^3.","category":"page"},{"location":"surfaces_def/#NURBS-Surfaces","page":"Surfaces","title":"NURBS Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"Analogously, a NURBS surface","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms(uv) = sum_i=1^B_u sum_j=1^B_v R_ij(uv) bmp_ij = cfracsum_i=1^B_u sum_j=1^B_v N_ip(u) N_jq(v) w_ij bmp_ijsum_i=1^B_u sum_j=1^B_v N_ip(u) N_jq(v) w_ij","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"is defined.","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"note: Note\nbms(uv) (u v) mapsto (xyz), that is, the surface is a mapping from the parametric space (u v) in 01^2 to the physical space mathbbR^3.","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces_def/#Derivatives","page":"Surfaces","title":"Derivatives","text":"","category":"section"},{"location":"surfaces_def/#B-Spline-Surfaces-2","page":"Surfaces","title":"B-Spline Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"The m-th derivative in u and m-th derivative in v of a B-spline surface is given as [1, p. 111]","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms^(mn)(uv) = cfracpartial^m+npartial^m u partial^n vbms(uv) = sum_i=1^B_u sum_j=1^B_v N_ip^(m)(u) N_jp^(n)(u) bmp_ij ","category":"page"},{"location":"surfaces_def/#NURBS-Surfaces-2","page":"Surfaces","title":"NURBS Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"The m-th derivative in u and m-th derivative in v of a NURBS surface is given as ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms^(mn)(uv) = cfracpartial^m+npartial^m u partial^n vbms(uv) = sum_i=1^B_u sum_j=1^B_v R_ij^(mn)(uv) bmp_ij ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"It can be computed as [1, p. 136]","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"beginaligned\nbms^(mn)(uv) = cfrac1w^(00)(uv) Bigg( bma^(mn)(uv) \n- sum_i=1^m beginpmatrix m  i endpmatrix w^(i0)(uv) bms^(m-i n)(uv)  \n- sum_j=1^n beginpmatrix n  j endpmatrix w^(0j)(uv) bms^(m n-j)(uv) \n- sum_i=1^m beginpmatrix m  i endpmatrix sum_j=1^n beginpmatrix n  j endpmatrix   w^(ij)(uv) bms^(m-i n-j)(uv) Bigg) \nendaligned","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"with","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bma^(mn)(uv) = sum_i=1^B_u sum_j=1^B_v N_ip^(m)(u) N_jq^(n)(v) w_ij bmp_ij ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"and","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"w^(mn)(uv) = sum_i=1^B_u sum_j=1^B_v N_ip^(m)(u) N_jq^(n)(v) w_ij  ","category":"page"},{"location":"surfaces_def/#jac","page":"Surfaces","title":"Jacobian","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"The Jacobian matrix bmJ(uv) for the surface is given as","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bmJ(uv) = beginbmatrix cfracpartial xpartial u  cfracpartial xpartial v 3mm cfracpartial ypartial u  cfracpartial ypartial v 3mm cfracpartial zpartial u  cfracpartial zpartial v endbmatrix  = beginbmatrix bms^(1 0)  bms^(0 1) endbmatrix","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"and the magnitude of its determinant as","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"leftdetleft(bmJ(uv)right)right = sqrt left( cfracpartial ypartial ucfracpartial zpartial v - cfracpartial zpartial u cfracpartial ypartial v right)^2 + left( cfracpartial zpartial ucfracpartial xpartial v - cfracpartial xpartial u cfracpartial vpartial v right)^2 + left( cfracpartial xpartial ucfracpartial ypartial v - cfracpartial ypartial u cfracpartial xpartial v right)^2  ","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"For convenince the following utils are provided.","category":"page"},{"location":"utils/#File-I/O","page":"Utils","title":"File I/O","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"To read multipatch files as defined and provided by the nurbs Octave implementation and BEMBEL a function readMultipatch is provided.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"note: Note\nApart from these files the implementation in this package is done independendly from the Octave package. Similarities are accidentally (as it is also based on [1]). Also note, that the Octave package so far provides more functionality.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"using NURBS # hide\nPatches = readMultipatch(\"assets/sphere.dat\")\n\nusing PlotlyJS\nplotPatches(Patches, plotControlPoints=true, resolution=0.1)\nt = plotPatches(Patches, plotControlPoints=true, resolution=0.1) # hide\nsavefig(t, \"sphere.html\"); nothing # hide","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"<object data=\"../sphere.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"utils/#Jacobian","page":"Utils","title":"Jacobian","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"To compute the Jacobian matrix and its generalized determinant a function Jacobian is provided.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nJ, dJ = Jacobian(Patches[1], uEvalpoints, vEvalpoints)\nnothing # hide","category":"page"},{"location":"fundOperations/#Fundamental-Operations","page":"Fundamental Operations","title":"Fundamental Operations","text":"","category":"section"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"Fundamental operations to manipulate curves and surfaces are provided.","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"","category":"page"},{"location":"fundOperations/#Knot-Insertion","page":"Fundamental Operations","title":"Knot Insertion","text":"","category":"section"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"To insert a knot r times into a curve without changing the curve the insertKnot function is provided. The knot value is allowed to be already in the knot vector.","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"As an example consider the original curve:","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"using NURBS # hide\n# --- define curve\nusing StaticArrays\n\nkVec = Float64[0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5]\nkVec ./= maximum(kVec)\n\np = 3 # polynomial degree\n\nP1 = SVector(0.0, 0.0, 0.0)\nP2 = SVector(0.1, 0.25, 0.0)\nP3 = SVector(0.25, 0.3, 0.0)\nP4 = SVector(0.3, 0.5, 0.0)\nP5 = SVector(0.4, 0.4, 0.0)\nP6 = SVector(0.6, 0.3, 0.0)\nP7 = SVector(0.8, 0.7, 1.0)\nP8 = SVector(1.0, 0.4, 0.0)\nP8 = SVector(1.5, 0.4, 0.0)\n\ncontrolPoints = [P1, P2, P3, P4, P5, P6, P7, P8]\nw             = [1.0, 0.1, 1.0, 1.0, 1.0, 1.0, 3.0, 1.0]\n\n# --- evaluate original curve\nevalpoints = collect(0:0.005:1.0)\n\nN  = BsplineCurve(Bspline(p, kVec), controlPoints)\nC1 = N(evalpoints)\n\n# --- plot the curve\nusing PlotlyJS\n\nplotCurve3D(C1, controlPoints=controlPoints)\nt = plotCurve3D(C1, controlPoints=controlPoints) # hide\nsavefig(t, \"curveBeforeInsert.html\"); nothing # hide","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"<object data=\"../curveBeforeInsert.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"Now an already existing knot is inserted twice:","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"uNew = 3 / 5\nkVecNew, ctrlPointsNew, wNew = insertKnot(kVec, controlPoints, p, uNew, 2, w)\n\n# --- evaluate curve with inserted point\nN = BsplineCurve(Bspline(p, kVecNew), ctrlPointsNew)\nC2 = N(evalpoints)\n\n# --- plot the curve\nplotCurve3D(C2, controlPoints=ctrlPointsNew)\nt = plotCurve3D(C2, controlPoints=ctrlPointsNew) # hide\nsavefig(t, \"curveAfterInsert.html\"); nothing # hide","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"<object data=\"../curveAfterInsert.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"","category":"page"},{"location":"fundOperations/#Knot-Refinement","page":"Fundamental Operations","title":"Knot Refinement","text":"","category":"section"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"To be done.","category":"page"},{"location":"knotRemoval/#Knot-Removal","page":"Knot Removal","title":"Knot Removal","text":"","category":"section"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"To be done.","category":"page"},{"location":"curves_def/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"Based on both bases curves are defined.","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves_def/#Definitions","page":"Curves","title":"Definitions","text":"","category":"section"},{"location":"curves_def/#B-Spline-Curves","page":"Curves","title":"B-Spline Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"Based on the B-splines N_ip the p-th degree curve [1, p. 80]","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc(u) = sum_i=1^B N_ip(u) bmp_i","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"is defined with the constant controlpoints bmp_i in mathbbR^3.","category":"page"},{"location":"curves_def/#NURBS-Curves","page":"Curves","title":"NURBS Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"Analogously, the p-th degree NURBS curve [1, p. 117].","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc(u) = sum_i=1^B R_ip(u) bmp_i = cfracsum_i=1^B N_ip(u) w_i bmp_isum_i=1^B N_ip(u) w_i","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"is defined.","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"note: Note\nbmc(u) u mapsto (xyz), that is, the curve is a mapping from the parametric space u in 01 to the physical space mathbbR^3.","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves_def/#Derivatives","page":"Curves","title":"Derivatives","text":"","category":"section"},{"location":"curves_def/#B-Spline-Curves-2","page":"Curves","title":"B-Spline Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"The k-th derivative of a B-spline curve is given as [1, p. 91]","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc^(k)(u) = sum_i=1^B N_ip^(k)(u) bmp_i ","category":"page"},{"location":"curves_def/#NURBS-Curves-2","page":"Curves","title":"NURBS Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"The k-th derivative of a NURBS curve is given as","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc^(k)(u) = sum_i=1^B R_ip^(k)(u) bmp_i ","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"It can be computed as [1, p. 125]","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc^(k)(u) = cfracbma^(k)(u) - sum_i=1^k beginpmatrix k  i endpmatrix w^(i)(u) bmc^(k-i)(u)  w^(0)(u)","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"with the auxiliary","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bma^(k)(u) = sum_i=1^B N_ip^(k)(u) w_i bmp_i","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"and","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"w^(k)(u) = sum_i=1^B N_ip^(k)(u) w_i ","category":"page"},{"location":"degreeReduction/#Degree-Reduction","page":"Degree Reduction","title":"Degree Reduction","text":"","category":"section"},{"location":"degreeReduction/","page":"Degree Reduction","title":"Degree Reduction","text":"To be done.","category":"page"},{"location":"surfaces/#Surfaces","page":"Surfaces","title":"Surfaces","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Two type of surfaces are available:","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"B-splines surfaces\nNURBS surfaces","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Both are defined by initializing corresponding structures.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Define-Structures","page":"Surfaces","title":"Define Structures","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"NURBS and B-spline surfaces are defined by initializing a BsplineSurface or a NURBSsurface structure, respectively.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using NURBS # hide\nusing StaticArrays\n\n# --- parameters\nkVec = Float64[0, 0, 0, 1, 2, 3, 4, 5, 5, 5] # knot vector\nkVec ./= maximum(kVec)                       # normalize it\n\np = 2 # degree of the basis\n\n# --- control points\ncontrolPoints = [[SVector(0.0,0.0,3.0), SVector(0.0,1.0,3.0), SVector(0.0,2.0,2.0), SVector(0.0,3.0,2.0), SVector(0.0,4.0,2.0), SVector(0.0,5.0,2.0), SVector(0.0,6.0,2.0)],\n                 [SVector(1.0,0.0,3.0), SVector(1.0,1.0,3.0), SVector(1.0,2.0,2.0), SVector(1.0,3.0,2.0), SVector(1.0,4.0,2.0), SVector(1.0,5.0,2.0), SVector(1.0,6.0,2.0)],\n                 [SVector(2.0,0.0,2.0), SVector(2.0,1.0,2.0), SVector(2.0,2.0,1.0), SVector(2.0,3.0,1.0), SVector(2.0,4.0,1.0), SVector(2.0,5.0,1.0), SVector(2.0,6.0,1.0)],\n                 [SVector(3.0,0.0,2.0), SVector(3.0,1.0,2.0), SVector(3.0,2.0,1.0), SVector(3.0,3.0,1.0), SVector(3.0,4.0,1.0), SVector(3.0,5.0,0.0), SVector(3.0,7.0,0.0)],\n                 [SVector(4.0,0.0,1.0), SVector(4.0,1.0,1.0), SVector(4.0,2.0,0.0), SVector(4.0,3.0,0.0), SVector(4.0,4.0,1.0), SVector(4.0,5.0,0.0), SVector(4.0,6.0,0.0)],\n                 [SVector(5.0,0.0,1.0), SVector(5.0,1.0,1.0), SVector(5.0,2.0,0.0), SVector(5.0,3.0,0.0), SVector(5.0,4.0,0.0), SVector(5.0,5.0,0.0), SVector(5.0,6.0,0.0)],\n                 [SVector(6.0,0.0,1.0), SVector(6.0,1.0,1.0), SVector(6.0,2.0,0.0), SVector(6.0,3.0,0.0), SVector(6.0,4.0,0.0), SVector(6.0,5.0,0.0), SVector(6.0,6.0,0.0)]]\n\ncontrolPoints = [controlPoints[i][j] for i in 1:7, j in 1:7]\n\n# --- weights for the NURBS basis\nw = ones(size(controlPoints)) \nw[5,5] = 2.0\nw[7,2] = 0.8\n\n# --- initialize structures (using the same basis in both parametric directions)\nPatchB = BsplineSurface(Bspline(p, kVec), Bspline(p, kVec), controlPoints) \nPatchN = NURBSsurface(Bspline(p, kVec), Bspline(p, kVec), controlPoints, w)\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Evaluate-Points-on-the-Surface","page":"Surfaces","title":"Evaluate Points on the Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To evaluate the surfaces at parametric points hand over the latter. ","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nSBspline = PatchB(uEvalpoints, vEvalpoints)\nSNurbs   = PatchN(vEvalpoints, vEvalpoints)\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To plot the surfaces the plotSurface or the plotPatches functions are provided, where the latter evaluates the surface points itself.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"note: Note\nThe PlotlyJS.jl package has to be loaded in order to make the functions available. Reason is the employed Requires.jl framework.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using PlotlyJS\n\nplotSurface(SNurbs, controlPoints=controlPoints)\nt = plotSurface(SNurbs, controlPoints=controlPoints, enforceRatio=false) # hide\nsavefig(t, \"surface3D.html\"); nothing # hide\n\n# alternatively\nplotPatches([PatchN], plotControlPoints=true)","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"../surface3D.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Evaluate-Derivatives-of-the-Surface","page":"Surfaces","title":"Evaluate Derivatives of the Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To evaluate derivatives of surfaces at parametric points hand over hte latter and the maximum derivative to be evaluated.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nS = PatchN(uEvalpoints, vEvalpoints, 2) # 0-th, 1st, and 2nd derivatives\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"The plotSurface function has an optional argument tangents to plot vectors at the points of the curve.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using PlotlyJS\n\nplotSurface(S[1, 1], tangents=S[2,1], controlPoints=PatchN.controlPoints, enforceRatio=false)\nt = plotSurface(S[1, 1], tangents=S[2,1], controlPoints=PatchN.controlPoints, enforceRatio=false) # hide\nsavefig(t, \"surface3Dder.html\"); nothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"../surface3Dder.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"knotInsertion/#knotInsert","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"The insertion of knots into a knot vector of a curve or a surface without changing the curve or the surface is a fundamental operation. It is of use for [1, p. 142]:","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"evaluating points and derivatives on curves and surfaces\nsubdividing curves and surfaces\nadding control points in order to increase flexibility for interactive design control","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Inserting-Knots-into-a-Curve","page":"Knot Insertion","title":"Inserting Knots into a Curve","text":"","category":"section"},{"location":"knotInsertion/#Inserting-a-Single-Knot","page":"Knot Insertion","title":"Inserting a Single Knot","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"A given curve bmc(u) = sum_i=1^B N_ip(u) bmp_i defined on the knot vector","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"U = u_1 dots u_M","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"can be represented equivalently by inserting baru into U at the kth position resulting in the extended knot vector","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"barU = baru_1=u_1 dots baru_k = u_k baru_k+1=baru baru_k+2=u_k+1 dots baru_barM = u_M ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"as","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"bmc(u) = sum_i=1^barB barN_ip(u) barbmp_i ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"where barM = M+1 and barB = B+1 and the barN_ip are the pth degree basis functions defined on barU.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"note: Note\nHence, there are two tasks to fulfill:determining the position index k and the resulting barU for a given baru\ndetermining the barbmp_i","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"While the first one is a standard task, the second one can be computed as [1, p. 143]","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"barbmp_i = alpha_i bmp_i + (1 - alpha_i) bmp_i-1","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"with the coefficients","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"alpha_i = begincases 1  i leq k - p  cfracbaru - u_i  u_i+p - u_i  k - p + 1 leq i leq k  0  i geq k + 1 endcases ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"In consequence, p new control points have to be computed replacing p-1 existing ones.","category":"page"},{"location":"knotInsertion/#Inserting-Mulitple-Knots","page":"Knot Insertion","title":"Inserting Mulitple Knots","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"If the point baru to be inserted, already exists s times in U and shall be inserted r additional times, the above formula generalizes to [1, p. 149]","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"barbmp_ir = alpha_ir barbmp_i r-1 + (1 - alpha_ir) barbmp_i-1 r-1","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"with barbmp_i0 = bmp_i and","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"alpha_ir = begincases 1  i leq k - p + r - 1  cfracbaru - u_i  u_i+p-r+1 - u_i  k - p + r leq i leq k - s  0  i geq k - s + 1 endcases ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"note: Note\np-s+r-1 new control points are computed.\np-s-1 control points are replaced starting at index k - p + 1.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Knot-Refinement","page":"Knot Insertion","title":"Knot Refinement","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"To be done.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Curve-Splitting","page":"Knot Insertion","title":"Curve Splitting","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"To be done.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Surface-Knot-Insertion","page":"Knot Insertion","title":"Surface Knot Insertion","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"To be done.","category":"page"},{"location":"#NURBS.jl","page":"Introduction","title":"NURBS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides functionality to define and evaluate B-spline and NURBS (non-uniform rational B-spline) basis functions, their derivatives, as well as curves and surfaces based on both considered basis functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following aspects are implemented (‚úì) and planned (‚åõ):","category":"page"},{"location":"#B-spline-and-NURBS-evaluation","page":"Introduction","title":"B-spline & NURBS evaluation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"‚úì Basis & derivatives\n‚úì Curves & derivatives\n‚úì Surfaces & derivatives","category":"page"},{"location":"#Fundamental-operations","page":"Introduction","title":"Fundamental operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"‚úì File I/O (basic)\n‚åõ Knot insertion / removal\n‚åõ Degree elevation / reduction\n‚åõ Construction of common geometries","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Basically, chapters 2-4 of [1] are implemented so far (adapted to 1-based indexing).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nOpen knot vectors are assumed everywhere, if not stated otherwise.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThe parametric space is assumed to be 0 1 or 01^2  everywhere.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Installing NURBS is done by entering the package manager (enter ] at the julia REPL) and issuing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add NURBS ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#refs","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The implementation is based on","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1] L. Piegl, The NURBS Book, Berlin Heidelberg, Springer-Verlag, 1997.\n[2] R.N. Simpson, et. al, A Two-Dimensional Isogeometric Boundary Element Method for Elastostatic Analysis, Comput. Methods Appl. Mech. Engrg., 2012.","category":"page"}]
}
