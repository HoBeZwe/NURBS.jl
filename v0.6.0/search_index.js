var documenterSearchIndex = {"docs":
[{"location":"curves/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Two type of curves are available:","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"B-splines curves\nNURBS curves","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Both are defined by initializing corresponding structures.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Define-Structures","page":"Curves","title":"Define Structures","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"NURBS and B-spline curves are defined by initializing a BsplineCurve or a NURBScurve structure, respectively.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using NURBS # hide\n# --- parameters\nkVec = Float64[0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 6, 6, 6] # knot vector\nkVec ./= maximum(kVec)                                # normalize it\n\np = 3  # degree \n\n# --- control points\nusing StaticArrays\nP1 = SVector(0.0, 0.0, 0.0)\nP2 = SVector(0.1, 0.25, 0.0)\nP3 = SVector(0.25, 0.3, 0.0)\nP4 = SVector(0.3, 0.5, 0.0)\nP5 = SVector(0.4, 0.4, 0.0)\nP6 = SVector(0.6, 0.3, 0.0)\nP7 = SVector(0.8, 0.7, 1.0)\nP8 = SVector(1.0, 0.4, 0.0)\nP9 = SVector(1.1, 0.4, 0.0)\n\ncontrolPoints = [P1 , P2 , P3 , P4 , P5 , P6 , P7 , P8 , P9 ]\nw             = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 3.0, 1.0, 1.0] # weights for the NURBS\n\n# --- the structures\nBCurve = BsplineCurve(Bspline(p, kVec), controlPoints)\nNCurve   = NURBScurve(NURB(p, kVec, w), controlPoints)\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Evaluate-Points-of-a-Curve","page":"Curves","title":"Evaluate Points of a Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"To evaluate the curves at parametric points simply hand over the latter. ","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"evalpoints = collect(0:0.0005:1.0)\n\nCBspline = BCurve(evalpoints)\nCNurbs   = NCurve(evalpoints)\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"To plot the curves the plotCurve3D and the plotCurve functions are provided, where the latter ignores any z-components.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"note: Note\nThe PlotlyJS.jl package has to be loaded in order to make the functions available. (It is a weak dependency.)","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using PlotlyJS\n\nplotCurve3D(CBspline, controlPoints=controlPoints)\nt = plotCurve3D(CBspline, controlPoints=controlPoints) # hide\nsavefig(t, \"cruve3D.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3D.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Evaluate-Derivatives-of-a-Curve","page":"Curves","title":"Evaluate Derivatives of a Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"To evaluate derivatives of curves at parametric points hand over the latter and the maximum derivative to be evaluated.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"evalpoints = collect(0:0.0005:1.0)\n\nC = NCurve(evalpoints, 2) # 0-th, 1st, and 2nd derivatives\nnothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"The plotCurve3D function has an optional argument tangents to plot vectors at the points of the curve.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"using PlotlyJS\n\nplotCurve3D(C[1], controlPoints=controlPoints, tangents=C[2])\nt = plotCurve3D(C[1], controlPoints=controlPoints, tangents=C[2]) # hide\nsavefig(t, \"cruve3Dder.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3Dder.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Refining-a-Curve","page":"Curves","title":"Refining a Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Based on the principles of knot insertion, a single knot can be inserted multiple times into a curve (without changing the points the curve describes) by the insertKnot function.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"NCurve2 = insertKnot(NCurve, 0.75, 2) # insert knot at 0.75 twice\nC2 = NCurve2(evalpoints)\n\nplotCurve3D(C2, controlPoints=NCurve2.controlPoints)\nt = plotCurve3D(C2, controlPoints=NCurve2.controlPoints) # hide\nsavefig(t, \"cruve3DInserted.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3DInserted.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"Several knots can be inserted by the refine function.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"NCurve2 = refine(NCurve, [0.1, 0.2, 0.3, 0.8221]) # insert the array of knots\nC2 = NCurve2(evalpoints)\n\nplotCurve3D(C2, controlPoints=NCurve2.controlPoints)\nt = plotCurve3D(C2, controlPoints=NCurve2.controlPoints) # hide\nsavefig(t, \"cruve3Drefined.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3Drefined.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"note: Note\nRefining a curve does not change the points in space described by the curve. Effectively, in the plots it can be seen that the number of control points is increased.  However, also underlying properties such as the differentiability are changed.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Splitting-a-Curve","page":"Curves","title":"Splitting a Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"To split a curve into multiple separate curves the function split is provided which returns an array of curves.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"cVec = split(NCurve, [0.2, 0.5]) # split at 0.2 and 0.5\n\n# plot all three curves\ndata = PlotlyJS.GenericTrace[]\nfor (i, spC) in enumerate(cVec)\n    push!(data, plotCurve3D(spC(evalpoints), returnTrace=true, controlPoints=spC.controlPoints)...)\nend\nPlotlyJS.plot(data)\nt = PlotlyJS.plot(data) # hide\nsavefig(t, \"cruve3Dsplit.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3Dsplit.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"To equally split a curve into n curves as a second argument an integer can be provided:","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"cVec = split(NCurve, 4) # split into 4 curves","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves/#Removing-Knots-from-a-Curve","page":"Curves","title":"Removing Knots from a Curve","text":"","category":"section"},{"location":"curves/","page":"Curves","title":"Curves","text":"Based on the principles of knot removal, an interior knot can potentially be removed multiple times from a curve (without changing the points the curve describes) by the removeKnot function.","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"p = 3\n\nP1 = SVector(0.0, 0.0, 1.0)\nP2 = SVector(0.0, 2.0, 0.0)\nP3 = SVector(1.5, 3.0, 0.0)\nP4 = SVector(3.0, 3.0, 0.0)\nP5 = SVector(4.5, 3.0, 0.0)\nP6 = SVector(6.0, 2.0, 0.0)\nP7 = SVector(6.0, 0.0, 1.0)\n\ncP = [P1, P2, P3, P4, P5, P6, P7]\n\nkVec = Float64[0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2]\n\nBCurve1 = BsplineCurve(Bspline(p, kVec), cP)\nC1 = BCurve1(evalpoints)\n\nBCurve2 = removeKnot(BCurve1, 0.5, 2) # remove knot at 0.5 twice\nC2 = BCurve2(evalpoints)\n\n# --- plot both curves \nt1 = plotCurve3D(C1, controlPoints=BCurve1.controlPoints, returnTrace=true)\nt2 = plotCurve3D(C2, controlPoints=BCurve2.controlPoints, returnTrace=true)\n\nfig = make_subplots(\n    rows=1, cols=2,\n    specs=fill(Spec(kind=\"scene\"), 1, 2)\n)\n\nadd_trace!(fig, t1[1], row=1, col=1)\nadd_trace!(fig, t1[2], row=1, col=1)\nadd_trace!(fig, t2[1], row=1, col=2)\nadd_trace!(fig, t2[2], row=1, col=2)\nfig\nsavefig(fig, \"cruve3DRemoved.html\"); nothing # hide","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"<object data=\"../cruve3DRemoved.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"curves/","page":"Curves","title":"Curves","text":"note: Note\nRemoving a knot from a curve is only possible when the continuity of the curve is sufficient at the knot. A central part of the removeKnot function is to verify if the knot can actually be removed. If not, warnings are generated, indicating the encountered limitations.","category":"page"},{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/","page":"API Reference","title":"API Reference","text":"Modules = [NURBS]","category":"page"},{"location":"apiref/#Core.Union-Tuple{Any, NURBS.pAlloc}","page":"API Reference","title":"Core.Union","text":"(basis::Bspline)(evalpoints)\n\nEvaluate B-spline basis at all evalpoints.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Core.Union-Tuple{Any}","page":"API Reference","title":"Core.Union","text":"(basis::Bspline)(evalpoints)\n\nEvaluate B-spline basis at all evalpoints.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.Bspline","page":"API Reference","title":"NURBS.Bspline","text":"Bspline{F} <: Basis{F}\n\nB-spline basis.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.Bspline-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.Bspline","text":"(basis::Bspline)(evalpoints, k::Int)\n\nEvaluate k-the derivative of B-spline basis at all evalpoints (all basis functions different from 0 at the evalpoints are evaluated).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.Bspline-Union{Tuple{T}, Tuple{Vector{T}, Int64, NURBS.pAllocDer}} where T","page":"API Reference","title":"NURBS.Bspline","text":"(basis::Bspline)(evalpoints, k::Int, prealloc)\n\nEvaluate k-the derivative of B-spline basis at all evalpoints (all basis functions different from 0 at the evalpoints are evaluated).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineCurve","page":"API Reference","title":"NURBS.BsplineCurve","text":"BsplineCurve{F} <: Curve{F}\n\nB-spline curve defined by the basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.BsplineCurve-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.BsplineCurve","text":"(curve::BsplineCurve)(uVector, k::Int)\n\nConvenience function to compute points on all k derivatives of a B-spline curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineCurve-Tuple{Any}","page":"API Reference","title":"NURBS.BsplineCurve","text":"(curve::BsplineCurve)(uVector)\n\nConvenience function to compute points on a B-spline curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineSurface","page":"API Reference","title":"NURBS.BsplineSurface","text":"BsplineSurface{F} <: Surface{F}\n\nSurface defined by a B-spline basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.BsplineSurface-Tuple{Any, Any, Int64}","page":"API Reference","title":"NURBS.BsplineSurface","text":"(Patch::BsplineSurface)(uEvalpoints, vEvalpoints, k::Int)\n\nConvenience function to compute points on all k derivatives of a B-spline surface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.BsplineSurface-Tuple{Any, Any}","page":"API Reference","title":"NURBS.BsplineSurface","text":"(Patch::BsplineSurface)(uEvalpoints, vEvalpoints)\n\nConvenience function to compute points on a B-spline surface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.CurrySchoenberg","page":"API Reference","title":"NURBS.CurrySchoenberg","text":"CurrySchoenberg{F} <: Basis{F}\n\nNormalized B-spline basis.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURB","page":"API Reference","title":"NURBS.NURB","text":"NURB{F} <: Basis{F}\n\nNURBS basis.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBScurve","page":"API Reference","title":"NURBS.NURBScurve","text":"NURBScurve{F} <: Curve{F}\n\nB-spline curve defined by the basis and the control points.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBScurve-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.NURBScurve","text":"(curve::NURBScurve)(uVector, k::Int)\n\nConvenience function to compute points on all k derivatives of a NURBS curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURBScurve-Tuple{Any}","page":"API Reference","title":"NURBS.NURBScurve","text":"(curve::NURBScurve)(uVector)\n\nConvenience function to compute points on a NURBS curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURBSsurface","page":"API Reference","title":"NURBS.NURBSsurface","text":"NURBSsurface{F} <: Surface{F}\n\nSurface defined by a B-spline basis, the control points, and the weights.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#NURBS.NURBSsurface-Tuple{Any, Any, Int64, NURBS.pAllocNURBSsuface}","page":"API Reference","title":"NURBS.NURBSsurface","text":"(Patch::NURBSsurface)(uEvalpoints, vEvalpoints, k::Int, prealloc)\n\nConvenience function to compute points on all k derivatives of a NURBSsurface, for preallocated memory.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURBSsurface-Tuple{Any, Any, Int64}","page":"API Reference","title":"NURBS.NURBSsurface","text":"(Patch::NURBSsurface)(uEvalpoints, vEvalpoints, k::Int)\n\nConvenience function to compute points on all k derivatives of a NURBSsurface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.NURBSsurface-Tuple{Any, Any}","page":"API Reference","title":"NURBS.NURBSsurface","text":"(Patch::NURBSsurface)(uEvalpoints, vEvalpoints)\n\nConvenience function to compute points on a NURBSsurface.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Base.split","page":"API Reference","title":"Base.split","text":"Base.split(C::Curve, splitPoint=0.5)\n\nSplit a curve at a single parametric point in the range ]0,1[ by inserting a single knot multiple times.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#Base.split-Tuple{NURBS.Curve, Int64}","page":"API Reference","title":"Base.split","text":"Base.split(C::Curve, n::Int)\n\nSplit a curve in the parametric domain equally to obtain n curves.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Base.split-Tuple{Surface, Int64, Int64}","page":"API Reference","title":"Base.split","text":"Base.split(C::Curve, n::Int)\n\nSplit a curve in the parametric domain equally to obtain n curves.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Base.split-Tuple{SurfaceT} where SurfaceT<:Surface","page":"API Reference","title":"Base.split","text":"Base.split(S::SurfaceT; U=[], V=[]) where {SurfaceT<:Surface}\n\nSplit a surface at multiple parametric points in U and V, each in the range ]0,1[, by inserting knots.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Base.split-Union{Tuple{CurveT}, Tuple{CurveT, Vector}} where CurveT<:NURBS.Curve","page":"API Reference","title":"Base.split","text":"Base.split(C::CurveT, splits::Vector) where {CurveT<:Curve}\n\nSplit a curve at multiple parametric points, each in the range ]0,1[, by inserting knots.\n\nThe splits vector needs to be sorted and each value should only occur once.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#LinearAlgebra.rotate!-Union{Tuple{T}, Tuple{S}, Tuple{S, StaticArraysCore.SVector{3, T}, Real}} where {S<:NURBS.Shape, T}","page":"API Reference","title":"LinearAlgebra.rotate!","text":"rotate!(shape::S, rotAxis::SVector{3,T}, angle::Real) where {S<:Shape,T}\n\nRotate a shape around the rotation axis by an angle (in rad).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#LinearAlgebra.rotate!-Union{Tuple{T}, Tuple{S}, Tuple{Vector{S}, StaticArraysCore.SVector{3, T}, Real}} where {S<:NURBS.Shape, T}","page":"API Reference","title":"LinearAlgebra.rotate!","text":"rotate!(shapes::Vector{S}, rotAxis::SVector{3,T}, angle::Real) where {S<:Shape,T}\n\nRotate a vector of shapes around the rotation axis by an angle (in rad).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.JacobiDet-Tuple{Any, Any}","page":"API Reference","title":"NURBS.JacobiDet","text":"JacobiDet(Ju, Jv)\n\nCompute Jacobi determinant from the Jacobi matrix\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.Jacobian-Tuple{Surface, Any, Any}","page":"API Reference","title":"NURBS.Jacobian","text":"Jacobian(Patch::Surface, uEvalpoints, vEvalpoints)\n\nCompute the Jacobian matrix and its (generalized) determinant at the parametric points 'uEvalpoints' and 'vEvalpoints'.\n\nReturn     - J     2-dimensional vector: first for the derivative w.r.t 'u', second w.r.t 'v'                 each vector entry contains a matrix of size (uEvalpoints, vEvalpoints)                 each entry of the matrix is an SVector with the derivatives: SVector(∂x/∂u, ∂y/∂u, ∂y/∂u)\n\n- dJ    matrix of size (uEvalpoints, vEvalpoints) where each entry is the Jacobi determinant evaluated at the points 'u' and 'v'.\n\nNote: surface points are evaluated but thrown away: maybe change this/make use of it.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.anchors-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.anchors","text":"anchors(kVec, degree::Int)\n\nReturn the anchors (as defined in [4]) corresponding to the given knotvector and the polynomial degree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Int64, Any}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, degree::Int, evalpoints; normalize=true)\n\ni-th b-spline basis function of degree 'degree' evaluated at all 'evalpoints'.\n\nThe knotvector is assumed to be normalized to [1, 0].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Int64, Real}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, degree::Int, u::Real)\n\ni-th b-spline basis function of degree 'degree' evaluated at u.\n\nFormula (2.5) of 'The NURBS Book' p. 50.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaive-Tuple{Any, Int64, Real}","page":"API Reference","title":"NURBS.bSplineNaive","text":"bSplineNaive(knotVector, i::Int, u::Real)\n\ni-th b-spline basis function of degree 0 evaluated at u.\n\nFormula (2.5) of 'The NURBS Book' p. 50.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaiveDerivative-Tuple{Any, Int64, Int64, Any, Int64}","page":"API Reference","title":"NURBS.bSplineNaiveDerivative","text":"bSplineNaiveDer(knotVector, i::Int, degree::Int, evalpoints, k::Int; normalize=true)\n\nCompute the k-th derivative of i-th b-spline basis function of degree 'degree' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.bSplineNaiveDerivative-Tuple{Any, Int64, Int64, Real, Int64}","page":"API Reference","title":"NURBS.bSplineNaiveDerivative","text":"bSplineNaiveDerivative(knotVector, i::Int, degree::Int, u::Real, k::Int)\n\nk-th derivative of the i-th b-spline basis function of degree 'degree' evaluated at (single) point 'u'.\n\nFormula (2.9) of 'The NURBS Book' p. 61. (Recursive implementation to avoid the faculties in the (2.10) formula.)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.basisFun!-Tuple{NURBS.pAlloc, Any, Any, NURBS.Basis}","page":"API Reference","title":"NURBS.basisFun!","text":"basisFun!(prealloc::pAlloc, knotSpan, uVector, basis::Basis)\n\nCompute the nonvanishing B-spline basis functions of degree 'degree' at the parametric points defined by 'uVector'\n\nReturn the B-spline basis functions vector of size length(uVector) * (degree + 1).\n\nAdapted from Algorithm A2.2 from 'The NURBS Book' p. 70.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.basisFun-Tuple{Any, Any, NURBS.Basis}","page":"API Reference","title":"NURBS.basisFun","text":"basisFun(knotSpan, uVector, basis::Basis)\n\nAllocate memory and call basisFun!    \n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.checkRange-Tuple{Real}","page":"API Reference","title":"NURBS.checkRange","text":"checkRange(point<:Real)\n\nCheck whether points is greater 0 and smaller 1.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{Int64, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curveDerivativesPoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector, weights, k::Int)\n\nCompute points on the k-th derivatives of a NURBS curve: given the 'knotVector', the 'controlPoints', the 'degree', and the 'weights', the curve is evaluated at the points given in 'uVector'.\n\nUsing (4.8) on page 125 of 'The NURBS Book'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curveDerivativesPoints-Tuple{Int64, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.curveDerivativesPoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector)\n\nCompute a points on the k-th derivatives of a B-spline curve: given the 'knotVector', the 'controlPoints', and the 'degree', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{NURBS.Basis, Any, Any, Any}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(nbasisFun::Int, degree::Int, knotVector, controlPoints, uVector, weights)\n\nCompute points on a NURBS curve: given the 'knotVector', the 'controlPoints', the 'degree', and the 'weights', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.curvePoints-Tuple{NURBS.Basis, Any, Any}","page":"API Reference","title":"NURBS.curvePoints","text":"curvePoints(basis::Basis, controlPoints, uVector)\n\nCompute a 1D B-spline curve: given the 'knotVector', the 'controlPoints', and the 'degree', the curve is evaluated at the points given in 'uVector'.\n\nExample for the controlPoints:\n\nP1 = SVector(0.0, 0.0, 0.0) P2 = SVector(0.1, 0.25, 0.0) P3 = SVector(0.25, 0.3, 0.0)\n\ncontrolPoints = [P1, P2, P3]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.derBasisFun!-Tuple{NURBS.pAllocDer, Any, Int64, Any, Any, Int64}","page":"API Reference","title":"NURBS.derBasisFun!","text":"derBasisFun!(knotSpan, degree::Int, evalpoints, knotVector, numberDerivatives::Int)\n\nCompute the nonvanishing B-spline basis functions and its derivatives of degree 'degree' at the parametric points defined by 'uVector'.\n\nOrganization of output:  dersv[n, k, :] contains (k-1)-th derivative at n-th point.\n\nAdapted from Algorithm A2.3 from 'The NURBS BOOK' p. 72.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.derBasisFun-Union{Tuple{T}, Tuple{Any, Int64, Vector{T}, Any, Int64}} where T","page":"API Reference","title":"NURBS.derBasisFun","text":"derBasisFun(degree::Int, evalpoints, knotVector, numberDerivatives::Int)\n\nSame as derBasisFun! but with memory allocation.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaive-Tuple{NURB, Int64, Any}","page":"API Reference","title":"NURBS.evalNaive","text":"evalNaive(basis::NURB, i::Int, evalpoints)\n\ni-th NURB basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaive-Tuple{NURBS.Basis, Int64, Any}","page":"API Reference","title":"NURBS.evalNaive","text":"evalNaive(basis::Basis, i::Int, evalpoints)\n\ni-th B-spline or Curry-Schoenberg basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaiveDerivative-Tuple{Bspline, Int64, Int64, Any}","page":"API Reference","title":"NURBS.evalNaiveDerivative","text":"evalNaiveDerivative(basis::Bspline, i::Int, k::Int, evalpoints)\n\nCompute the k-th derivative of i-th b-spline basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.evalNaiveDerivative-Tuple{NURB, Int64, Int64, Any}","page":"API Reference","title":"NURBS.evalNaiveDerivative","text":"evalNaiveDerivative(basis::NURB, i::Int, k::Int, evalpoints)\n\nCompute the k-th derivative of i-th NURBS basis function evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.extendControlPoints!","page":"API Reference","title":"NURBS.extendControlPoints!","text":"extendControlPoints!(controlPoints, knotVecOrig, degree::Int, pos::Int, uNew::Real, multiplicity::Int, oldMult::Int, weights)\n\nInsert the new control points (and optionally the weights) corresponding to the new values in the knot vector 'multiplicity' times.\n\nAdaption of Algorithm A5.1 from 'The NURBS Book' p. 151.\n\nModifies controlPoints and weights.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.extendKnotVector!-Tuple{Any, Int64, Real, Int64}","page":"API Reference","title":"NURBS.extendKnotVector!","text":"extendKnotVector!(knotVecOrig, newParametricPoint::Real, multiplicity::Int)\n\nInsert the new value with a given mulitplicity (insert the point multiple times).\n\nModifies knotVecOrig.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.extractBracketList","page":"API Reference","title":"NURBS.extractBracketList","text":"extractBracketList(line::String, nextInd::Int, T=Float64)\n\nGiven a string with a list of numbers between two brackets (e.g., (2,3,1,5,...,6)), extract the numbers.\n\nAs second output the index after ')' is returned.\n\n'nextInd' is the index of the '(' in 'line'.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.extractCtrlPoints","page":"API Reference","title":"NURBS.extractCtrlPoints","text":"extractCtrlPoints(line::String, firstCommaInd::Int, points, offset::Int, T=Float64)\n\nExtract a list of points between '((' and '))' in the line starting from 'firstCommaInd' of the format \n\n    ((#349,#350,#351,#352,#353),(#354,#355,#356,#357,#358),(#359,#360,#361,#362,#363),(#364,#365,#366,#367,#368),(#369,#370,#371,#372,#373))\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.extractKnotVecs","page":"API Reference","title":"NURBS.extractKnotVecs","text":"extractKnotVecs(line::String, startInd::Int, T=Float64)\n\nExtract the knot vectors from the 'line' of the format 'SOMESTRING(5,5),(5,5),(0.,1.),(0.,1.)SOMESTRING' where 'startInd' points to the 'G'.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.findSpan!-Union{Tuple{T}, Tuple{Any, T, Any, Any, T}} where T<:Int64","page":"API Reference","title":"NURBS.findSpan!","text":"findSpan!(spanVec, b::T, uVec, kVec, p::T)\n\nFind the spans of a B-spline knot vector at the parametric points 'u', where 'b' is the number of basis functions (control points).\n\nSpan: the intervall index in which a point lies. E.g., knotVector = [0, 1, 2, 3, 4]. Hence, there are 4 intervalls. u=1.2 lies in the second intervall.\n\nModification of Algorithm A2.1 from 'The NURBS Book' p. 68.\n\nAssumption that the knotVector is open! (the first and last knot are repeated degree + 1 times)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.findSpan-Union{Tuple{T}, Tuple{T, Any, Any, T}} where T<:Int64","page":"API Reference","title":"NURBS.findSpan","text":"findSpan(b::T, uVec, kVec, p::T)\n\nAllocate memory and call findSpan!    \n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.generateKnotVec-Tuple{Int64, Int64}","page":"API Reference","title":"NURBS.generateKnotVec","text":"generateKnotVec(b::Int, degree::Int)\n\nConvenience function to generate a knot vector for 'b' basis functions and a certain 'degree': \n\nThe first and last entry are repeated 'degree'+1 times. Normalized to [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.getCartesianPoints","page":"API Reference","title":"NURBS.getCartesianPoints","text":"getCartesianPoints(stringVec)\n\nExtract all Cartesian points and the offset between the first point and the #counting. (Assumption: all points appear in a consecutive list.)\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.getCompleteString-Tuple{Vector{String}, Int64}","page":"API Reference","title":"NURBS.getCompleteString","text":"getCompleteString(stringVec::String, nextLineInd::Int)\n\nRetreive all lines of the string vector 'stringVec' starting from 'nextLineInd' till a semicolon is encountered.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.getCompleteStringTill-Tuple{Any, Int64, String}","page":"API Reference","title":"NURBS.getCompleteStringTill","text":"getCompleteStringTill(stringVec, nextLineInd::Int, stopWhenEncountered::String)\n\nRetreive all lines of the string vector 'stringVec' starting from 'nextLineInd' till the next line starts with 'stopWhenEncountered'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.greville-Tuple{Any, Int64}","page":"API Reference","title":"NURBS.greville","text":"greville(kVec, degree::Int)\n\nReturn the Greville sites (as defined in [3]) corresponding to the given knotvector and the polynomial degree.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.insertKnot","page":"API Reference","title":"NURBS.insertKnot","text":"insertKnot(knotVecOrig, controlPointsOrig, p::Int, newParametricPoint::Real, multiplicity::Int)\n\nInsert a new value with a given mulitplicity (insert the value multiple times) into a knot vector for the polynomial degree 'degree'. Return the resutling knot vector and the new control points.\n\nAdaption of Algorithm A5.1 from 'The NURBS Book' p. 151.\n\nThe provided knot vector and control-point vector are NOT modified.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.insertKnot-2","page":"API Reference","title":"NURBS.insertKnot","text":"insertKnot(C::Curve, newParametricPoint::Real, multiplicity::Int)\n\nConvenience function to insert a knot into a curve.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.insertKnot!","page":"API Reference","title":"NURBS.insertKnot!","text":"insertKnot!(knotVecOrig, controlPointsOrig, p::Int, newParametricPoint::Real, multiplicity::Int)\n\nInsert a new value with a given mulitplicity (insert the value multiple times) into a knot vector for the polynomial degree 'degree'. Return the resutling knot vector and the new control points.\n\nAdaption of Algorithm A5.1 from 'The NURBS Book' p. 151.\n\nThe provided knot vector and control-point vector are modified.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.insertKnotU","page":"API Reference","title":"NURBS.insertKnotU","text":"insertKnotU(S::Surface, newParametricPoint::Real, multiplicity::Int=1)\n\nInsert a knot in u-direction with the given multiplicity.\n\nTODO: the computation of the alphas is redundant.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.insertKnotV","page":"API Reference","title":"NURBS.insertKnotV","text":"insertKnotV(S::Surface, newParametricPoint::Real, multiplicity::Int=1)\n\nInsert a knot in v-direction with the given multiplicity.\n\nTODO: the computation of the alphas is redundant.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.isValidKnotVector!-Tuple{Any}","page":"API Reference","title":"NURBS.isValidKnotVector!","text":"isValidKnotVector!(kVec)\n\nCheck whether the knot vector has only entries in [0, 1] and is in ascending order.\n\nIf not the knot vector is modified.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.mirror!-Union{Tuple{T}, Tuple{S}, Tuple{S, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where {S<:NURBS.Shape, T}","page":"API Reference","title":"NURBS.mirror!","text":"translate!(shape::S, shift::SVector{3,T}) where {S<:Shape, T}\n\nMirror a shape through a plane defined by its normal and an anchor point.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.mirror!-Union{Tuple{T}, Tuple{S}, Tuple{Vector{S}, StaticArraysCore.SVector{3, T}, StaticArraysCore.SVector{3, T}}} where {S<:NURBS.Shape, T}","page":"API Reference","title":"NURBS.mirror!","text":"mirror!(shapes::Vector{S}, normal::SVector{3,T}, anchor::SVector{3,T}) where {S<:Shape,T}\n\nMirror a vector of shapes through a plane defined by its normal and an anchor point.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.mirror-Tuple{Any, Any, Any}","page":"API Reference","title":"NURBS.mirror","text":"mirror(shape, rotAxis, angle)\n\nMirror through a plane defined by its normal and an anchor point.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.normalization-Tuple{CurrySchoenberg, Int64}","page":"API Reference","title":"NURBS.normalization","text":"normalization(basis::CurrySchoenberg, i::Int)\n\nNormalization for the standard B-splines to obtain Curry-Schoenberg splines.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.normalization-Tuple{NURBS.Basis, Int64}","page":"API Reference","title":"NURBS.normalization","text":"normalization(basis::Basis, i::Int)\n\nFor Bsplines there is no normalization.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.normalizationDerivative-Tuple{Any, Int64, Any, Real, Int64}","page":"API Reference","title":"NURBS.normalizationDerivative","text":"normalizationDerivative(knotVector, degree::Int, weights, u::Real, k::Int)\n\nReturn the k-th derivative of the weight function (21) in [2].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.normalize!-Union{Tuple{T}, Tuple{Any, T, T, Any, CurrySchoenberg}} where T<:Int64","page":"API Reference","title":"NURBS.normalize!","text":"normalize!(N, i::T, degree::T, knotVector, basis::CurrySchoenberg)\n\nNormalize the standard B-splines to obtain Curry-Schoenberg splines.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.normalize!-Union{Tuple{T}, Tuple{Any, T, T, Any, NURBS.Basis}} where T<:Int64","page":"API Reference","title":"NURBS.normalize!","text":"normalize!(N, i::T, degree::T, knotVector, basis::Bspline)\n\nFor Bsplines there is no normalization.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.numBasisFunctions-Tuple{NURBS.Basis}","page":"API Reference","title":"NURBS.numBasisFunctions","text":"numBasisFunctions(basis::Basis)\n\nThe number of basis functions is fixed by the knot vector and the degree.\n\nAssumption: the first and last knot vector entry has mulitplicity degree + 1.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaive-Tuple{Any, Int64, Int64, Any, Any}","page":"API Reference","title":"NURBS.nurbsNaive","text":"nurbsNaive(knotVector, i::Int, degree::Int, evalpoints, weights)\n\ni-th NURB basis function of degree 'degree', the 'knotVector', and with 'weights' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaive-Tuple{Any, Int64, Int64, Real, Any}","page":"API Reference","title":"NURBS.nurbsNaive","text":"nurbsNaive(knotVector, i::Int, degree::Int, u::Real, weights)\n\ni-th NURB basis function of degree 'degree', the 'knotVector', and with 'weights' evaluated at single point 'u'.\n\nFormula (4.2) of 'The NURBS Book' p. 118. \n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaiveDerivative-Tuple{Any, Int64, Int64, Any, Any, Int64}","page":"API Reference","title":"NURBS.nurbsNaiveDerivative","text":"nurbsNaiveDerivative(knotVector, i::Int, degree::Int, weights, evalpoints, k::Int; normalize=true)\n\nCompute the k-th derivative of i-th NURBS basis function of degree 'degree' evaluated at all 'evalpoints'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.nurbsNaiveDerivative-Tuple{Any, Int64, Int64, Any, Real, Int64}","page":"API Reference","title":"NURBS.nurbsNaiveDerivative","text":"nurbsNaiveDerivative(knotVector, i::Int, degree::Int, weights, u::Real, k::Int)\n\nk-th derivative of the i-th NURBS basis function of degree 'degree' evaluated at (single) point 'u'.\n\nFormula (52) of [2].\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.parseCtrlPoints","page":"API Reference","title":"NURBS.parseCtrlPoints","text":"parseCtrlPoints(pointDims, stringVec, T=Float64)\n\nTake the 3 strings in 'stringVec' and parse it into a pointDims[1] x pointDims[2] matrix where each entry is a SVector for a controlpoint.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.parseLine","page":"API Reference","title":"NURBS.parseLine","text":"parseLine(line::String, T=Float64)\n\nTake the string 'line' of the form '0.1 0.2 0.6 ...' and parse it to a vector with eltype 'T'.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.parseSinglePatch-Tuple{Any, Int64, Any}","page":"API Reference","title":"NURBS.parseSinglePatch","text":"parseSinglePatch(stringVec, lineInd)\n\nTake the string vector and the line index where \"PATCH\" stands and extract the information of a single patch\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.parse_B_SPLINE_SURFACE_WITH_KNOTS","page":"API Reference","title":"NURBS.parse_B_SPLINE_SURFACE_WITH_KNOTS","text":"parse_B_SPLINE_SURFACE_WITH_KNOTS(line::String, points, offset::Int, T=Float64)\n\nParse a BSPLINESURFACEWITHKNOTS\n\nExample:\n\n#13764=BSPLINESURFACEWITHKNOTS('',3,3,((#16247,#16248,#16249,#16250, #16251),(#16252,#16253,#16254,#16255,#16256),(#16257,#16258,#16259,#16260, #16261),(#16262,#16263,#16264,#16265,#16266),(#16267,#16268,#16269,#16270, #16271)),.UNSPECIFIED.,.F.,.F.,.F.,(4,1,4),(4,1,4),(0.,1.,2.),(0.,1.,2.),  .UNSPECIFIED.);\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.parse_NURBS_step","page":"API Reference","title":"NURBS.parse_NURBS_step","text":"parse_NURBS(lineCtlPts::String, lineKnVecs::String, lineWeight::String, points, offset::Int, T=Float64)\n\nExample:\n\n#163=( BOUNDEDSURFACE() BSPLINESURFACE(4,4,((#349,#350,#351,#352,#353),(#354,#355,#356,#357,#358), (#359,#360,#361,#362,#363),(#364,#365,#366,#367,#368),(#369,#370,#371,#372, #373)),.UNSPECIFIED.,.F.,.F.,.F.) BSPLINESURFACEWITHKNOTS((5,5),(5,5),(0.,1.),(0.,1.),.UNSPECIFIED.) GEOMETRICREPRESENTATIONITEM() RATIONALBSPLINESURFACE(((5.07179676972449,4.52004210360334,4.35726558990816, 4.52004210360334,5.07179676972449),(4.52004210360334,3.86602540378444,3.64492370567392, 3.86602540378444,4.52004210360334),(4.35726558990816,3.64492370567392,3.40455735015306, 3.64492370567392,4.35726558990816),(4.52004210360334,3.86602540378444,3.64492370567392, 3.86602540378444,4.52004210360334),(5.07179676972449,4.52004210360334,4.35726558990816, 4.52004210360334,5.07179676972449))) REPRESENTATION_ITEM('') SURFACE() );\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.preAlloc-Union{Tuple{T}, Tuple{Int64, Vector{T}}} where T","page":"API Reference","title":"NURBS.preAlloc","text":"preAlloc(degree::Int, uVector::Vector{T})\n\nAllocate memory for basisFun.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.preAllocDer-Union{Tuple{T}, Tuple{Int64, Vector{T}, Int64}} where T","page":"API Reference","title":"NURBS.preAllocDer","text":"preAlloc(degree::Int, evalpoints, numberDerivatives::Int)\n\nAllocate memory for derBasisFun.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.preAllocNURBSsurface-Tuple{Int64, Int64, Any, Any, Int64}","page":"API Reference","title":"NURBS.preAllocNURBSsurface","text":"preAllocNURBSsurface(uDegree::Int, vDegree::Int, uVector, vVector, k::Int)\n\nAllocate all memory for surfaceDerivativesPoints!\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.readMultipatch","page":"API Reference","title":"NURBS.readMultipatch","text":"readMultipatch(filename::String)\n\nRead multipatch file organized as:\n\nPATCH a 4 4             -> degree in u and v 5 5             -> number of control points in u and v 0.0 0.0 ...     -> knot vector in u 0.0 0.0 ...     -> knot vector in v 0.1 0.2 ...     | 0.1 0.2 ...      > xyz components of the control points (normalized with the weigths -> we remove this weighting when reading in the data) 0.1 0.2 ...     | 1.0 1.0 ...     -> weights\n\nPATCH b  ...\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.readStep","page":"API Reference","title":"NURBS.readStep","text":"readStep(filename::String, T=Float64)\n\nRead a step file. \n\nSo far only BSPLINESURFACEWITHKNOTS and BOUNDED_SURFACE() are supported.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.refine","page":"API Reference","title":"NURBS.refine","text":"refine(kVec::Vector, controlPts::Vector, degree::Int, newParametricPoints::Vector, weights=[])\n\nRefine a curve by inserting new parametric points into the curve's knot vector.\n\nNOTE: There are more efficient ways to do this. See, e.g., 'The NURBS Book' p. 162.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.refine-Tuple{NURBS.Curve, Vector}","page":"API Reference","title":"NURBS.refine","text":"refine(C::Curve, newParametricPoints::Vector)\n\nConvenience function to refine a curve.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.refine-Tuple{Surface}","page":"API Reference","title":"NURBS.refine","text":"refine(S::Surface; U=[], V=[])\n\nNOTE: There are more efficient ways to do this.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.removeKnot","page":"API Reference","title":"NURBS.removeKnot","text":"removeKnot(knotVec, controlPoints, degree::Int, pointToRemove::Real, multiplicity::Int, weights)\n\nRemove a knot 'multiplicity' times.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.removeKnot!","page":"API Reference","title":"NURBS.removeKnot!","text":"removeKnot!(knotVec, controlPoints, degree::Int, pointToRemove::Real, multiplicity::Int, weights)\n\nModifies solely 'knotVec', 'controlPoints', and 'weights'.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.removeKnot-Tuple{NURBS.Curve, Real, Int64}","page":"API Reference","title":"NURBS.removeKnot","text":"removeKnot(C::Curve, pointToRemove::Real, multiplicity::Int)\n\nRemove a knot from a curve ´multiplicity´ times.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.removeKnotU-Tuple{Surface, Real, Int64}","page":"API Reference","title":"NURBS.removeKnotU","text":"removeKnotU(S::Surface, pointToRemove::Real, multiplicity::Int)\n\nRemove a knot in u-direction 'multiplicity' times.\n\nTODO: replace by more efficient algorithm of Tiller.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.removeKnotV-Tuple{Surface, Real, Int64}","page":"API Reference","title":"NURBS.removeKnotV","text":"removeKnotV(S::Surface, pointToRemove::Real, multiplicity::Int)\n\nRemove a knot in v-direction 'multiplicity' times.\n\nTODO: replace by more efficient algorithm of Tiller.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.rotate-Tuple{Any, Any, Any}","page":"API Reference","title":"NURBS.rotate","text":"rotate(shape, rotAxis, angle)\n\nRotate a shape around the rotation axis by an angle (in rad).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.rotationMatrix-Union{Tuple{T}, Tuple{Any, T}} where T","page":"API Reference","title":"NURBS.rotationMatrix","text":"rotationMatrix(rotAxis, angle::Real)\n\nDetermine rotation matrix for a rotation axis and an angle (in rad). \n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.scale!-Union{Tuple{S}, Tuple{Vector{S}, Real}} where S<:NURBS.Shape","page":"API Reference","title":"NURBS.scale!","text":"scale!(shapes::T, factor::Real) where {T<:Shape}\n\nScale a vector of shapes by a real factor.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.scale!-Union{Tuple{T}, Tuple{T, Real}} where T<:NURBS.Shape","page":"API Reference","title":"NURBS.scale!","text":"scale!(shape::T, factor::Real) where {T<:Shape}\n\nScale a shape by a real factor\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.scale-Tuple{Any, Any}","page":"API Reference","title":"NURBS.scale","text":"scale(shape, factor)\n\nScale a shape by a real factor.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.similarCurve-Tuple{BsplineCurve, Int64, Any, Any, Any}","page":"API Reference","title":"NURBS.similarCurve","text":"similarCurve(curve::BsplineCurve, p::Int, kVec, cPts, w)\n\nConstruct B-spline curve from underlying data: ignore empty weights.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.similarCurve-Tuple{NURBScurve, Int64, Any, Any, Any}","page":"API Reference","title":"NURBS.similarCurve","text":"similarCurve(curve::NURBScurve, p::Int, kVec, cPts, w)\n\nConstruct NURBS curve from underlying data.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.similarSurface-Tuple{BsplineSurface, Int64, Int64, Vararg{Any, 4}}","page":"API Reference","title":"NURBS.similarSurface","text":"similarSurface(surface::BsplineSurface, pu::Int, pv::Int, uVec, vVec, cPts, w)\n\nConstruct B-spline surface from underlying data: ignore empty weights.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.similarSurface-Tuple{NURBSsurface, Int64, Int64, Vararg{Any, 4}}","page":"API Reference","title":"NURBS.similarSurface","text":"similarSurface(surface::NURBSsurface, pu::Int, pv::Int, uVec, vVec, cPts, weights)\n\nConstruct NURBS surface from underlying data.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.spanRanges-Tuple{Bspline, Any}","page":"API Reference","title":"NURBS.spanRanges","text":"spanRanges(Bspl::Bspline, points)\n\nDetermine the ranges of the points which lie in each span of the B-spline (assuming normalized open knot vectors).\n\nReturn a vector of ranges (one entry per span).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.splitControlPoints-Tuple{Int64, Vararg{Any, 7}}","page":"API Reference","title":"NURBS.splitControlPoints","text":"splitControlPoints(degree::Int, wOri, ctrlPtsOri, kVecOri, oldMultIndices, oldMult, limitedMult, splitPoint)\n\nSplit the control points (and the weights) by inserting a knot multiple times.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.splitData-Tuple{Int64, Vararg{Any, 4}}","page":"API Reference","title":"NURBS.splitData","text":"splitData(degree::Int, wOri, kVecOri, ctrlPtsOri, splitPoint=0.5)\n\nSplit the underlying data of a curve at a single parametric point in the range ]0,1[ by inserting a single knot multiple times.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.splitKnots-Tuple{Int64, Any, Any}","page":"API Reference","title":"NURBS.splitKnots","text":"splitKnots(degree::Int, kVecOri, splitPoint)\n\nSplit knot vector according to the split point.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.splitU-Union{Tuple{SurfaceT}, Tuple{SurfaceT, Vector}} where SurfaceT<:Surface","page":"API Reference","title":"NURBS.splitU","text":"splitU(S::SurfaceT, splits::Vector) where {SurfaceT<:Surface}\n\nSplit a surface along the u-direction at multiple parametric points, each in the range ]0,1[, by inserting knots.\n\nThe splits vector needs to be sorted and each value should only occur once (both are not checked since this function is meant for internal use).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.splitV-Union{Tuple{SurfaceT}, Tuple{SurfaceT, Vector}} where SurfaceT<:Surface","page":"API Reference","title":"NURBS.splitV","text":"splitV(S::SurfaceT, splits::Vector) where {SurfaceT<:Surface}\n\nSplit a surface along the v-direction at multiple parametric points, each in the range ]0,1[, by inserting knots.\n\nThe splits vector needs to be sorted and each value should only occur once (both are not checked since this function is meant for internal use).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.splitWeights-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T","page":"API Reference","title":"NURBS.splitWeights","text":"splitWeights(weights::Vector{T}, Ind::Int) where {T}\n\nSplit the weights including the case when there are no weights.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints!-Tuple{NURBS.pAllocNURBSsuface, Int64, Int64, Any, Any, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints!","text":"surfaceDerivativesPoints!(prealloc, uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, weights, k::Int)\n\nCompute NURBS surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nUsing (4.20) on page 136 of 'The NURBS Book'.\n\nControl points ordering P_(xi,yj):\n\nP11 ––- P12 ––- P13 –-> y / v direction |          |         | |          |         | P21 ––- P22 ––- P23 |          |         | |          |         | P31 ––- P32 ––- P_33 | x / u direction\n\nReturns a (k x k) matrix where each entry is a matrix of size (uKnotVector x vKnotVector): surfaces[q, p] is the matrix for the (q-1)-th derivative in u-direction and the (p-1)-th derivative in v-direction.\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, weights, k::Int)\n\nAllocate memory and call surfaceDerivativesPoints!\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPoints-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Int64}","page":"API Reference","title":"NURBS.surfaceDerivativesPoints","text":"surfaceDerivativesPoints(uDegree::Int, vDegree::Int, uKnotVector, vKnotVector, controlPoints, uVector, vVector, k::Int)\n\nCompute B-spline surface and its derivatives: given the knotvectors and the degrees in 'u' and 'v' direction, the surface and its derivatives are evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ––- P12 ––- P13 –-> y / v direction |          |         | |          |         | P21 ––- P22 ––- P23 |          |         | |          |         | P31 ––- P32 ––- P_33 | x / u direction\n\nReturns a (k x k) matrix where each entry is a matrix of size (uKnotVector x vKnotVector): surfaces[q, p] is the matrix for the (q-1)-th derivative in u-direction and the (p-1)-th derivative in v-direction.\n\nNote: not the most efficient implementation. TODO: implement algorithm A.37 and A.38 of 'The Nurbs book'\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfaceDerivativesPointsUV-Tuple{Int64, Int64, Any, Any, Any, Any, Any, Int64, Int64, Any, Any}","page":"API Reference","title":"NURBS.surfaceDerivativesPointsUV","text":"surfaceDerivativesPointsUV(uDegree::Int, vDegree::Int, controlPoints, uVector, vVector, Nu, Nv, q::Int, p::Int, uSpan, vSpan)\n\nCompute the q-th derivative along 'u' and the p-th derivative along 'v'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{NURBS.Basis, NURBS.Basis, Any, Any, Any}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(uBasis::Basis, vBasis::Basis, controlPoints, uVector, vVector)\n\nCompute B-spline surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ––- P12 ––- P13 –-> y / v direction |          |         | |          |         | P21 ––- P22 ––- P23 |          |         | |          |         | P31 ––- P32 ––- P_33 | x / u direction\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.surfacePoints-Tuple{NURBS.Basis, NURBS.Basis, Vararg{Any, 4}}","page":"API Reference","title":"NURBS.surfacePoints","text":"surfacePoints(uBasis::Basis, vBasis::Basis, controlPoints, uVector, vVector, weights)\n\nCompute NURBS surface: given the knotvectors and the degrees in 'u' and 'v' direction, the surface is evaluated at the evaluation points (uVector, vVector).\n\nControl points ordering P_(xi,yj):\n\nP11 ––- P12 ––- P13 –-> y / v direction |          |         | |          |         | P21 ––- P22 ––- P23 |          |         | |          |         | P31 ––- P32 ––- P_33 | x / u direction\n\nNote: the efficient evaluation via the B-spline basis is employed (no use of the naive evaluation of the NURBS basis).\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.translate!-Union{Tuple{T}, Tuple{S}, Tuple{S, StaticArraysCore.SVector{3, T}}} where {S<:NURBS.Shape, T}","page":"API Reference","title":"NURBS.translate!","text":"translate!(shape::S, shift::SVector{3,T}) where {S<:Shape, T}\n\nTranslate a shape into the direction given by the vector 'shift'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.translate!-Union{Tuple{T}, Tuple{S}, Tuple{Vector{S}, StaticArraysCore.SVector{3, T}}} where {S<:NURBS.Shape, T}","page":"API Reference","title":"NURBS.translate!","text":"translate!(shapes::Vector{S}, shift::SVector{3, T}) where {S<:Shape, T}\n\nTranslate a vector of shapes into the direction given by the vector 'shift'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.translate-Tuple{Any, Any}","page":"API Reference","title":"NURBS.translate","text":"translate(shape, shift)\n\nTranslate a shape into the direction given by the vector 'shift'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.trimControlPoints!-Tuple{Any, Any, Int64, Int64, Real, Int64, Int64, Any}","page":"API Reference","title":"NURBS.trimControlPoints!","text":"trimControlPoints!(cPts, kVecOri, degree::Int, pos::Int, pointToRemove::Real, limitedMult::Int, oldMult::Int, weights)\n\nAdaption of Algorithm A5.8 from 'The NURBS Book' p. 185.\n\nModifies solely 'cPts' and 'weights'.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.trimability-Tuple{Any, Real, Int64}","page":"API Reference","title":"NURBS.trimability","text":"trimability(knotVec, pointToRemove::Real, multiplicity::Int)\n\nAnalyze the knot vector: how many times is the knot actually contained, at which positions, and how many times.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.weights","page":"API Reference","title":"NURBS.weights","text":"weights(srfc::NURBSsurface)\n\nReturn the weights of a NURBS surface.\n\n\n\n\n\n","category":"function"},{"location":"apiref/#NURBS.weights-Tuple{NURB}","page":"API Reference","title":"NURBS.weights","text":"weights(basis::NURB)\n\nReturn the weights of a NURBS basis.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.weights-Union{Tuple{NURBS.Basis{T}}, Tuple{T}} where T","page":"API Reference","title":"NURBS.weights","text":"weights(basis::Basis)\n\nExcept for a NURBS basis all other bases have no weights.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.weights-Union{Tuple{Surface{T}}, Tuple{T}, Tuple{Surface{T}, Any}, Tuple{Surface{T}, Any, Any}} where T","page":"API Reference","title":"NURBS.weights","text":"weights(srfc::Surface{T}, i=0, j=0) where {T}\n\nExcept for a NURBS surfaces all other surfaces have no weights.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#NURBS.weights-Union{Tuple{T}, Tuple{Array{T}, Any, Any}} where T","page":"API Reference","title":"NURBS.weights","text":"weights(w::Array{T}, i, j) where {T}\n\nGeneral case.\n\n\n\n\n\n","category":"method"},{"location":"trafos/#Transformations","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"The following transformations can be applied to curves and surfaces.","category":"page"},{"location":"trafos/#Scaling","page":"Transformations","title":"Scaling","text":"","category":"section"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"To scale a curve or a surface, the functions scale and scale! are provided.","category":"page"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"using NURBS\nPatches = readMultipatch(\"assets/sphere.dat\")\n\nscale!(Patches, 2.3) # the sphere of radius 1 has now radius 2.3\nnothing # hide","category":"page"},{"location":"trafos/#Translating","page":"Transformations","title":"Translating","text":"","category":"section"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"To translate a curve or a surface, the functions translate and translate! are provided.","category":"page"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"using NURBS, StaticArrays\n\nshift = SVector(2.4,-1.0,0.5)\ntranslate!(Patches, shift) # move the whole sphere\nnothing # hide","category":"page"},{"location":"trafos/#Rotating","page":"Transformations","title":"Rotating","text":"","category":"section"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"To rotate a curve or a surface around a rotation axis by a given angle, the functions rotate and rotate! are provided.","category":"page"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"tip: Tip\nThe rotation axis is normalized by the rotate functions.","category":"page"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"using NURBS, StaticArrays\n\nrotAxis = SVector(1.0, 1.0, 1.0)\nα = π/3\n\nrotate!(Patches, rotAxis, α)\nnothing # hide","category":"page"},{"location":"trafos/#Mirroring","page":"Transformations","title":"Mirroring","text":"","category":"section"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"To mirror/reflect a shape through a plane defined by its normal vector and an anchor point, the functions mirror and mirror! are provided.","category":"page"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"tip: Tip\nThe normal vector is normalized by the mirror functions.","category":"page"},{"location":"trafos/","page":"Transformations","title":"Transformations","text":"using NURBS, StaticArrays\n\nnormal = SVector(0.0, 1.0, 0.0)\nanchor = SVector(0.0, 0.0, 0.0)\n\nmirror!(Patches, normal, anchor) # mirror through the xz-plane\nnothing # hide","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the main branch. Before doing so please: ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(NURBS))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"NURBS\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For more detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"NURBS\"; coverage=true, julia_args=`--threads 4`)\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(NURBS) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"NURBS.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the SphericalScattering.lcov.info file in the settings.","category":"page"},{"location":"degreeElevation/#Degree-Elevation","page":"Degree Elevation","title":"Degree Elevation","text":"","category":"section"},{"location":"degreeElevation/","page":"Degree Elevation","title":"Degree Elevation","text":"To be done.","category":"page"},{"location":"basis/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"The considered ","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"B-spline, \nCurry-Schoenberg, and \nNURBS ","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"basis functions are defined by initializing corresponding structures. A naive evaluation method is available for all, an efficient evaluation only for B-splines and Curry-Schoenberg splines.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Define-Structures","page":"Bases","title":"Define Structures","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"B-spline, Curry-Schoenberg, and NURBS bases are defined by initializing a Bspline, a CurrySchoenberg, or a NURB structure, respectively.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"using NURBS # hide\n# --- parameters\nb = 6       # number of basis functions\np = 2       # degree of NURBS\n\nw = ones(b) # weights for NURBS\nw[4] = 1.8\n\n# --- resulting knot vector\nkVec = generateKnotVec(b, p)\n\n# --- structures\nBspl = Bspline(p, kVec)\nNrbs = NURB(p, kVec, w)\nCspl = CurrySchoenberg(p, kVec)\nnothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Naive-Evaluation","page":"Bases","title":"Naive Evaluation","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"To evaluate the bases at certain points the evalNaive function is provided.  It directly implemens the defining equations of the B-splines, the CurrySchoenberg, and NURBS. For the derivatives the evalNaiveDerivative function is provided derectly implementing the defining equations of the derivatives.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"note: Note\nThe naive evaluation methods are solely implemented to play around with parameters (to get familiar with NURBS and B-splines). ","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"# --- define points where the bases are evaluated\nevalpoints = collect(0:0.001:1.0)\n\n# --- evaluate bases (4-th basis function)\nbspline = evalNaive(Bspl, 4, evalpoints) \nnurb    = evalNaive(Nrbs, 4, evalpoints)\ncspl    = evalNaive(Cspl, 4, evalpoints)\n\n# --- evaluate derivatives (1st derivative of 4-th basis function)\nbsplineD = evalNaiveDerivative(Bspl, 4, 1, evalpoints) \nnurbD    = evalNaiveDerivative(Nrbs, 4, 1, evalpoints)\n\n\nusing Plots\nplotly()\n\nPlots.plot(evalpoints, bspline, w=2, \n    label=\"B-spline\", \n    title=\"4-th basis function\", \n    xlabel=\"𝑢\", \n    ylabel=\"𝑁₄,₂(𝑢)\")\nPlots.plot!(evalpoints, nurb, w=2, label=\"NURB\")\nPlots.plot!(evalpoints, cspl, w=2, label=\"Curry-Schoenberg\")\nxlims!(0, 1) # hide\nylims!(0, 1) # hide\nsavefig(\"plotBspl.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBspl.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Plots.plot(evalpoints, bsplineD, w=2, \n    label=\"B-spline\", \n    title=\"1st derivative of 4-th basis function\", \n    xlabel=\"𝑢\", \n    ylabel=\"∂ᵤ 𝑁₄,₂(𝑢)\")\nPlots.plot!(evalpoints, nurbD, w=2, label=\"NURB\")\nxlims!(0, 1) # hide\nsavefig(\"plotBsplD.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBsplD.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis/#Efficient-Evaluation","page":"Bases","title":"Efficient Evaluation","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"For the B-splines and the Curry-Schoenberg splines the efficient evaluation of [1] is implemented by handing evaluation points to the Bspline structure and optionally as second argument (only for the B-splines) the maximum derivative that shall be computed. That is, only the basis functions different from zero are evaluated:","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"note: Note\nFor the evaluation of NURBS curves and surfaces (and their derivatives) the B-spline evaluation is sufficient.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"bspline  = Bspl(evalpoints)\ncrySbrg  = Cspl(evalpoints)\nbsplineD = Bspl(evalpoints, 2) # 0th, 1st, and 2nd derivative\n\n\nPlots.plot(evalpoints, bspline, w=2, \n    leg=false, \n    title=\"all basis functions\", \n    xlabel=\"𝑢\", \n    ylabel=\"𝑁ᵢ,₂(𝑢)\")\nxlims!(0, 1) # hide\nylims!(0, 1) # hide\nsavefig(\"plotBspleff.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBspleff.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Plots.plot(evalpoints, crySbrg, w=2, \n    leg=false, \n    title=\"all basis functions\", \n    xlabel=\"𝑢\", \n    ylabel=\"𝑛ᵢ,₂(𝑢)\")\nxlims!(0, 1) # hide\nylims!(0, 2.0) # hide\nsavefig(\"plotCspleff.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotCspleff.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"Plots.plot(evalpoints, bsplineD[:, 2, :], w=2, \n    leg=false,\n    title=\"1st derivative of all basis functions\", \n    xlabel=\"𝑢\", \n    ylabel=\"∂ᵤ 𝑁ᵢ,₂(𝑢)\")\nxlims!(0, 1) # hide\nsavefig(\"plotBsplDeff.html\"); nothing # hide","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"<object data=\"../plotBsplDeff.html\" type=\"text/html\"  style=\"width:120%;height:50vh;\"> </object>","category":"page"},{"location":"basis/#Memory-Preallocation","page":"Bases","title":"Memory Preallocation","text":"","category":"section"},{"location":"basis/","page":"Bases","title":"Bases","text":"In case B-splines shall be evaluated repeatedly memory can be preallocated and reused in subsequent calls:","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"tip: Tip\nThis is useful especially if single points are evaluated many times on demand.","category":"page"},{"location":"basis/","page":"Bases","title":"Bases","text":"pM = NURBS.preAlloc(p, evalpoints)\npD = NURBS.preAllocDer(p, evalpoints, 2)\n\nbspline  = Bspl(evalpoints, pM)\ncrySbrg  = Cspl(evalpoints, pM)\nbsplineD = Bspl(evalpoints, 2, pD) # 0th, 1st, and 2nd derivative\nnothing # hide","category":"page"},{"location":"basis_def/#Bases","page":"Bases","title":"Bases","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The considered ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"B-spline,\nCurry-Schoenberg, and\nNURBS ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"basis functions are based on a knot vector.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis_def/#kvec","page":"Bases","title":"Knot Vectors","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"Given a polynomial degree p in 1 2 3 dots, a knot vector of length M is defined as ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"U = u_1 dots u_M","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"where u_i leq u_i+1, i.e., the entries are sorted in ascending order, u_1 = 0, u_M = 1, and the first and last entry are each repeated p + 1 times.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"note: Note\nThis specific definition of the first and last entries defines an open knot vector; the only type of knot vector considered in this package.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"note: Note\nHaving u_i in 0 1 is assumed (and partially enforced) everywhere. ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis_def/#Definitions","page":"Bases","title":"Definitions","text":"","category":"section"},{"location":"basis_def/#bspl","page":"Bases","title":"B-Splines","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The B-spline basis functions of degree p are defined as N_ip on the knot vector U recursively, starting with the piecewise constant (p=0) [1, p. 50]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"N_i0(u) = begincases 1  u_i leq u  u_i+1  0  textotherwiseendcases","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"as well as for p0","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"N_ip(u) = cfracu - u_iu_i+p - u_i  N_i p-1(u) + cfracu_i+p+1 - uu_i+p+1 - u_i+1  N_i+1 p-1(u) ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"Whenever one of the contained quotients exhibits a division by 0, the quotient is defined to be 0 itself.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"note: Note\nThe number of basis functions B is related to the length of the knot vector M and the polynomial degree p asB = M - p - 1 ","category":"page"},{"location":"basis_def/#csspl","page":"Bases","title":"Curry-Schoenberg Splines","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The Curry-Schoenberg spline basis functions [3, p. 88]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"n_ip(u) = cfracp+1u_i+p+1 - u_i N_ip(u)","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"are defined as a normalized version of the B-splines. ","category":"page"},{"location":"basis_def/#nurbs","page":"Bases","title":"NURBS","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"Introducing B weights w_i in mathbbR_+ the rational B-spline basis functions [1, p. 118]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"R_i p(u) = cfracN_i p(u) w_isum_j=1^B N_j p(u) w_i","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"are defined based on the B-spline basis N_i p on the knot vector U.","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"","category":"page"},{"location":"basis_def/#derB","page":"Bases","title":"Derivatives","text":"","category":"section"},{"location":"basis_def/#B-Splines","page":"Bases","title":"B-Splines","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The k-th derivative of the B-splines N_i p can be computed as [1, p. 61]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"N_ip^(k)(u) = p left( cfracN_ip-1^(k-1)u_i+p - u_i - cfracN_i+1p-1^(k-1)u_i+p+1 - u_i+1 right) ","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"note: Note\nThe Curry-Schoenberg splines are related to the derivatives of the B-splines asN_ip^(1)(u) = n_ip-1(u) - n_i+1p-1(u) As this is their common use, derivatives of the Curry-Schoenberg splines are not used/implemented in this package.","category":"page"},{"location":"basis_def/#NURBS","page":"Bases","title":"NURBS","text":"","category":"section"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"The k-th derivative of the NURBS basis functions R_i p can be computed as [2]","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"R_ip^(k)(u) = cfracw_i  N_ip^(k)(u) - sum_j=1^k beginpmatrix k jendpmatrix W^(j)(u) R_ip^k-j(u)W^(0)(u)","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"with","category":"page"},{"location":"basis_def/","page":"Bases","title":"Bases","text":"W^(k)(u) = sum_i=1^B N_i p^(k)(u) w_i ","category":"page"},{"location":"surfaces_def/#Surfaces","page":"Surfaces","title":"Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"Based on both bases surfaces are defined.","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces_def/#Definitions","page":"Surfaces","title":"Definitions","text":"","category":"section"},{"location":"surfaces_def/#B-Spline-Surfaces","page":"Surfaces","title":"B-Spline Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"A tensor product surface [1, p. 100] ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms(uv) = sum_i=1^B_u sum_j=1^B_v N_ip(u) N_jq(v) bmp_ij","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"is defined by introducing two knot-vectors for the B-splines of degree p and q and a second parametric value v in 0 1, as well as a net of constant controlpoints bmp_ij in mathbbR^3.","category":"page"},{"location":"surfaces_def/#NURBS-Surfaces","page":"Surfaces","title":"NURBS Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"Analogously, a NURBS surface","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms(uv) = sum_i=1^B_u sum_j=1^B_v R_ij(uv) bmp_ij = cfracsum_i=1^B_u sum_j=1^B_v N_ip(u) N_jq(v) w_ij bmp_ijsum_i=1^B_u sum_j=1^B_v N_ip(u) N_jq(v) w_ij","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"is defined.","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"note: Note\nbms(uv) (u v) mapsto (xyz), that is, the surface is a mapping from the parametric space (u v) in 01^2 to the physical space mathbbR^3.","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces_def/#Derivatives","page":"Surfaces","title":"Derivatives","text":"","category":"section"},{"location":"surfaces_def/#B-Spline-Surfaces-2","page":"Surfaces","title":"B-Spline Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"The m-th derivative in u and m-th derivative in v of a B-spline surface is given as [1, p. 111]","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms^(mn)(uv) = cfracpartial^m+npartial^m u partial^n vbms(uv) = sum_i=1^B_u sum_j=1^B_v N_ip^(m)(u) N_jp^(n)(u) bmp_ij ","category":"page"},{"location":"surfaces_def/#NURBS-Surfaces-2","page":"Surfaces","title":"NURBS Surfaces","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"The m-th derivative in u and m-th derivative in v of a NURBS surface is given as ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bms^(mn)(uv) = cfracpartial^m+npartial^m u partial^n vbms(uv) = sum_i=1^B_u sum_j=1^B_v R_ij^(mn)(uv) bmp_ij ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"It can be computed as [1, p. 136]","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"beginaligned\nbms^(mn)(uv) = cfrac1w^(00)(uv) Bigg( bma^(mn)(uv) \n- sum_i=1^m beginpmatrix m  i endpmatrix w^(i0)(uv) bms^(m-i n)(uv)  \n- sum_j=1^n beginpmatrix n  j endpmatrix w^(0j)(uv) bms^(m n-j)(uv) \n- sum_i=1^m beginpmatrix m  i endpmatrix sum_j=1^n beginpmatrix n  j endpmatrix   w^(ij)(uv) bms^(m-i n-j)(uv) Bigg) \nendaligned","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"with","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bma^(mn)(uv) = sum_i=1^B_u sum_j=1^B_v N_ip^(m)(u) N_jq^(n)(v) w_ij bmp_ij ","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"and","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"w^(mn)(uv) = sum_i=1^B_u sum_j=1^B_v N_ip^(m)(u) N_jq^(n)(v) w_ij  ","category":"page"},{"location":"surfaces_def/#jac","page":"Surfaces","title":"Jacobian","text":"","category":"section"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"The Jacobian matrix bmJ(uv) for the surface is given as","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"bmJ(uv) = beginbmatrix cfracpartial xpartial u  cfracpartial xpartial v 3mm cfracpartial ypartial u  cfracpartial ypartial v 3mm cfracpartial zpartial u  cfracpartial zpartial v endbmatrix  = beginbmatrix bms^(1 0)  bms^(0 1) endbmatrix","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"and the magnitude of its determinant as","category":"page"},{"location":"surfaces_def/","page":"Surfaces","title":"Surfaces","text":"leftdetleft(bmJ(uv)right)right = sqrt left( cfracpartial ypartial ucfracpartial zpartial v - cfracpartial zpartial u cfracpartial ypartial v right)^2 + left( cfracpartial zpartial ucfracpartial xpartial v - cfracpartial xpartial u cfracpartial zpartial v right)^2 + left( cfracpartial xpartial ucfracpartial ypartial v - cfracpartial ypartial u cfracpartial xpartial v right)^2  ","category":"page"},{"location":"utils/#Utils","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"For convenince the following utils are provided.","category":"page"},{"location":"utils/#Jacobian","page":"Utils","title":"Jacobian","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"To compute the Jacobian matrix and its generalized determinant a function Jacobian is provided.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"using NURBS # hide\nPatches = readMultipatch(\"assets/sphere.dat\")\n\nuEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nJ, dJ = Jacobian(Patches[1], uEvalpoints, vEvalpoints)\nnothing # hide","category":"page"},{"location":"utils/#Greville-Sites","page":"Utils","title":"Greville Sites","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"To compute the Greville sites [3] ","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"gamma_i = cfracu_i+1+ dots + u_i+pp qquad i = 1 dots B","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"corresponding to a given knot vector with entries u_i and a polynomial degree p the function greville is provided.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"p = 2\n\nkVec = generateKnotVec(5, p)\nBspl = Bspline(p, kVec)\n\ngs = greville(Bspl)","category":"page"},{"location":"utils/#Anchor-Sites","page":"Utils","title":"Anchor Sites","text":"","category":"section"},{"location":"utils/","page":"Utils","title":"Utils","text":"To compute the anchors [4] corresponding to a given knot vector and a polynomial degree p the function anchors is provided.","category":"page"},{"location":"utils/","page":"Utils","title":"Utils","text":"ac = anchors(Bspl)","category":"page"},{"location":"fundOperations/#Fundamental-Operations","page":"Fundamental Operations","title":"Fundamental Operations","text":"","category":"section"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"Fundamental operations to manipulate curves and surfaces are provided.","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"","category":"page"},{"location":"fundOperations/#Knot-Insertion","page":"Fundamental Operations","title":"Knot Insertion","text":"","category":"section"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"To insert a knot r times into a curve without changing the curve the insertKnot function is provided. The knot value is allowed to be already in the knot vector.","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"As an example consider the original curve:","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"using NURBS # hide\n# --- define curve\nusing StaticArrays\n\nkVec = Float64[0, 0, 0, 0, 1, 2, 3, 4, 5, 5, 5, 5]\nkVec ./= maximum(kVec)\n\np = 3 # polynomial degree\n\nP1 = SVector(0.0, 0.0, 0.0)\nP2 = SVector(0.1, 0.25, 0.0)\nP3 = SVector(0.25, 0.3, 0.0)\nP4 = SVector(0.3, 0.5, 0.0)\nP5 = SVector(0.4, 0.4, 0.0)\nP6 = SVector(0.6, 0.3, 0.0)\nP7 = SVector(0.8, 0.7, 1.0)\nP8 = SVector(1.0, 0.4, 0.0)\nP8 = SVector(1.5, 0.4, 0.0)\n\ncontrolPoints = [P1, P2, P3, P4, P5, P6, P7, P8]\nw             = [1.0, 0.1, 1.0, 1.0, 1.0, 1.0, 3.0, 1.0]\n\n# --- evaluate original curve\nevalpoints = collect(0:0.005:1.0)\n\nN  = BsplineCurve(Bspline(p, kVec), controlPoints)\nC1 = N(evalpoints)\n\n# --- plot the curve\nusing PlotlyJS\n\nplotCurve3D(C1, controlPoints=controlPoints)\nt = plotCurve3D(C1, controlPoints=controlPoints) # hide\nsavefig(t, \"curveBeforeInsert.html\"); nothing # hide","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"<object data=\"../curveBeforeInsert.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"Now an already existing knot is inserted twice:","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"uNew = 3 / 5\nkVecNew, ctrlPointsNew, wNew = insertKnot(kVec, controlPoints, p, uNew, 2, w)\n\n# --- evaluate curve with inserted point\nN = BsplineCurve(Bspline(p, kVecNew), ctrlPointsNew)\nC2 = N(evalpoints)\n\n# --- plot the curve\nplotCurve3D(C2, controlPoints=ctrlPointsNew)\nt = plotCurve3D(C2, controlPoints=ctrlPointsNew) # hide\nsavefig(t, \"curveAfterInsert.html\"); nothing # hide","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"<object data=\"../curveAfterInsert.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"","category":"page"},{"location":"fundOperations/#Knot-Refinement","page":"Fundamental Operations","title":"Knot Refinement","text":"","category":"section"},{"location":"fundOperations/","page":"Fundamental Operations","title":"Fundamental Operations","text":"To be done.","category":"page"},{"location":"knotRemoval/#knotRemoval","page":"Knot Removal","title":"Knot Removal","text":"","category":"section"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"The removal of knots from a knot vector of a curve or a surface without changing the curve or the surface is a fundamental operation. It is of use for [1, p. 180]:","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"Converting curves and surfaces in power basis form to a B-spline representation\nObtaining most compat representation of a curve or surface\nCombining curves and surfaces","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"","category":"page"},{"location":"knotRemoval/#Removing-Knots-from-a-Curve","page":"Knot Removal","title":"Removing Knots from a Curve","text":"","category":"section"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"For a given curve bmc(u) = sum_i=1^B N_ip(u) bmp_i defined on the knot vector","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"U = u_1 dots u_M","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"the knot baru= u_r with multiplicity s is t times (1 leq t leq s) removable if the curve has an equivalent representation","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"bmc(u) = sum_i=1^barB barN_ip(u) barbmp_i ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"where and barB = B-t and the barN_ip are the pth degree basis functions defined on the trimmed knot vector barU.","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"note: Note\nHence, there are three tasks to fulfill:determining the position index r and the resulting barU for a given baru\ndetermine whether the knot is actually removable and how many times\ndetermining the barbmp_i","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"While the first one is a standard task, the second and third one can be achieved as follows [1, p. 183]:","category":"page"},{"location":"knotRemoval/#Removing-a-Knot-Once","page":"Knot Removal","title":"Removing a Knot Once","text":"","category":"section"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"For t=1, potentially n=p-s+1 control points have to be destroyed and replaced by n-1 new control points.","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"To see whether the knot is actually removable, the points ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"bmp^1_i = fracbmp_i^0 - (1-alpha_i)bmp_i-1^1alpha_i quad textfor quad r-p leq i leq 05(2r - p - s -1)","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"and","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"bmp^1_j = fracbmp_j^0 - alpha_jbmp_j+1^11 - alpha_j quad textfor quad 05(2r - p - s + 2) leq j leq r -s","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"are computed with ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"alpha_k = fracu_r - u_ku_k+p+1- u_k ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"Now, either ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"bmp_i^1 = bmp_j^1","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"has to hold, or","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"bmp_i^0 = alpha_i bmp_i^1 + (1 - alpha_i) bmp_j^1","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"in order for the knot to be removable. ","category":"page"},{"location":"knotRemoval/#Removing-a-Knot-Multiple-Times","page":"Knot Removal","title":"Removing a Knot Multiple Times","text":"","category":"section"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"For t geq 1 the points ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"bmp^t_i = fracbmp_i^t-1 - (1-alpha_i)bmp_i-1^talpha_i quad textfor quad r-p -t +1 leq i leq 05(2r - p - s - t)","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"and","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"bmp^t_j = fracbmp_j^t-1 - alpha_jbmp_j+1^t1 - alpha_j quad textfor quad 05(2r - p - s + t + 1) leq j leq r -s + t - 1","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"are computed with ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"alpha_i = fracu_r - u_iu_i+p+t- u_i ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"and","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"alpha_j = fracu_r - u_j-t+1u_j+p+1- u_j-t+1 ","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"","category":"page"},{"location":"knotRemoval/#Removing-Knots-from-a-Surface","page":"Knot Removal","title":"Removing Knots from a Surface","text":"","category":"section"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"Removing knots from a surface corresponds to applying the knot removal algorithm to all columns or rows.","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"info: Info\nA knot is only removable if it can be removed from all columns or rows.","category":"page"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"","category":"page"},{"location":"knotRemoval/#Combining-Curves-and-Surfaces","page":"Knot Removal","title":"Combining Curves and Surfaces","text":"","category":"section"},{"location":"knotRemoval/","page":"Knot Removal","title":"Knot Removal","text":"To be done.","category":"page"},{"location":"curves_def/#Curves","page":"Curves","title":"Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"Based on both bases curves are defined.","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves_def/#Definitions","page":"Curves","title":"Definitions","text":"","category":"section"},{"location":"curves_def/#B-Spline-Curves","page":"Curves","title":"B-Spline Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"Based on the B-splines N_ip the p-th degree curve [1, p. 80]","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc(u) = sum_i=1^B N_ip(u) bmp_i","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"is defined with the constant controlpoints bmp_i in mathbbR^3.","category":"page"},{"location":"curves_def/#NURBS-Curves","page":"Curves","title":"NURBS Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"Analogously, the p-th degree NURBS curve [1, p. 117].","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc(u) = sum_i=1^B R_ip(u) bmp_i = cfracsum_i=1^B N_ip(u) w_i bmp_isum_i=1^B N_ip(u) w_i","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"is defined.","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"note: Note\nbmc(u) u mapsto (xyz), that is, the curve is a mapping from the parametric space u in 01 to the physical space mathbbR^3.","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"","category":"page"},{"location":"curves_def/#Derivatives","page":"Curves","title":"Derivatives","text":"","category":"section"},{"location":"curves_def/#B-Spline-Curves-2","page":"Curves","title":"B-Spline Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"The k-th derivative of a B-spline curve is given as [1, p. 91]","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc^(k)(u) = sum_i=1^B N_ip^(k)(u) bmp_i ","category":"page"},{"location":"curves_def/#NURBS-Curves-2","page":"Curves","title":"NURBS Curves","text":"","category":"section"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"The k-th derivative of a NURBS curve is given as","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc^(k)(u) = sum_i=1^B R_ip^(k)(u) bmp_i ","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"It can be computed as [1, p. 125]","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bmc^(k)(u) = cfracbma^(k)(u) - sum_i=1^k beginpmatrix k  i endpmatrix w^(i)(u) bmc^(k-i)(u)  w^(0)(u)","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"with the auxiliary","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"bma^(k)(u) = sum_i=1^B N_ip^(k)(u) w_i bmp_i","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"and","category":"page"},{"location":"curves_def/","page":"Curves","title":"Curves","text":"w^(k)(u) = sum_i=1^B N_ip^(k)(u) w_i ","category":"page"},{"location":"degreeReduction/#Degree-Reduction","page":"Degree Reduction","title":"Degree Reduction","text":"","category":"section"},{"location":"degreeReduction/","page":"Degree Reduction","title":"Degree Reduction","text":"To be done.","category":"page"},{"location":"surfaces/#Surfaces","page":"Surfaces","title":"Surfaces","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Two type of surfaces are available:","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"B-splines surfaces\nNURBS surfaces","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Both are defined by initializing corresponding structures.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Define-Structures","page":"Surfaces","title":"Define Structures","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"NURBS and B-spline surfaces are defined by initializing a BsplineSurface or a NURBSsurface structure, respectively.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using NURBS # hide\nusing StaticArrays\n\n# --- parameters\nkVec = Float64[0, 0, 0, 1, 2, 3, 4, 5, 5, 5] # knot vector\nkVec ./= maximum(kVec)                       # normalize it\n\np = 2 # degree of the basis\n\n# --- control points\ncontrolPoints = [[SVector(0.0,0.0,3.0), SVector(0.0,1.0,3.0), SVector(0.0,2.0,2.0), SVector(0.0,3.0,2.0), SVector(0.0,4.0,2.0), SVector(0.0,5.0,2.0), SVector(0.0,6.0,2.0)],\n                 [SVector(1.0,0.0,3.0), SVector(1.0,1.0,3.0), SVector(1.0,2.0,2.0), SVector(1.0,3.0,2.0), SVector(1.0,4.0,2.0), SVector(1.0,5.0,2.0), SVector(1.0,6.0,2.0)],\n                 [SVector(2.0,0.0,2.0), SVector(2.0,1.0,2.0), SVector(2.0,2.0,1.0), SVector(2.0,3.0,1.0), SVector(2.0,4.0,1.0), SVector(2.0,5.0,1.0), SVector(2.0,6.0,1.0)],\n                 [SVector(3.0,0.0,2.0), SVector(3.0,1.0,2.0), SVector(3.0,2.0,1.0), SVector(3.0,3.0,1.0), SVector(3.0,4.0,1.0), SVector(3.0,5.0,0.0), SVector(3.0,7.0,0.0)],\n                 [SVector(4.0,0.0,1.0), SVector(4.0,1.0,1.0), SVector(4.0,2.0,0.0), SVector(4.0,3.0,0.0), SVector(4.0,4.0,1.0), SVector(4.0,5.0,0.0), SVector(4.0,6.0,0.0)],\n                 [SVector(5.0,0.0,1.0), SVector(5.0,1.0,1.0), SVector(5.0,2.0,0.0), SVector(5.0,3.0,0.0), SVector(5.0,4.0,0.0), SVector(5.0,5.0,0.0), SVector(5.0,6.0,0.0)],\n                 [SVector(6.0,0.0,1.0), SVector(6.0,1.0,1.0), SVector(6.0,2.0,0.0), SVector(6.0,3.0,0.0), SVector(6.0,4.0,0.0), SVector(6.0,5.0,0.0), SVector(6.0,6.0,0.0)]]\n\ncontrolPoints = [controlPoints[i][j] for i in 1:7, j in 1:7]\n\n# --- weights for the NURBS basis\nw = ones(size(controlPoints)) \nw[5,5] = 2.0\nw[7,2] = 0.8\n\n# --- initialize structures (using the same basis in both parametric directions)\nBSurface = BsplineSurface(Bspline(p, kVec), Bspline(p, kVec), controlPoints) \nNSurface = NURBSsurface(Bspline(p, kVec), Bspline(p, kVec), controlPoints, w)\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Evaluate-Points-on-a-Surface","page":"Surfaces","title":"Evaluate Points on a Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To evaluate the surfaces at parametric points hand over the latter. ","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nSBspline = BSurface(uEvalpoints, vEvalpoints)\nSNurbs   = NSurface(uEvalpoints, vEvalpoints)\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To plot the surfaces the plotSurface or the plotPatches functions are provided, where the latter evaluates the surface points itself.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"note: Note\nThe PlotlyJS.jl package has to be loaded in order to make the functions available. (It is a weak dependency.)","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using PlotlyJS\n\nplotSurface(SNurbs, controlPoints=controlPoints)\nt = plotSurface(SNurbs, controlPoints=controlPoints, enforceRatio=false) # hide\nsavefig(t, \"surface3D.html\"); nothing # hide\n\n# alternatively\n#plotPatches([NSurface], plotControlPoints=true)","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"../surface3D.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Evaluate-Derivatives-of-a-Surface","page":"Surfaces","title":"Evaluate Derivatives of a Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To evaluate derivatives of surfaces at parametric points hand over the latter and the maximum derivative to be evaluated.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"uEvalpoints = collect(0:0.01:1.0)\nvEvalpoints = collect(0:0.01:1.0)\n\nS = NSurface(uEvalpoints, vEvalpoints, 2) # 0-th, 1st, and 2nd derivatives\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"In case points (e.g., single points) shall be evaluated many times on demand, memory can be preallocated and reused in subsequent calls:","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"pM = NURBS.preAllocNURBSsurface(p, p, uEvalpoints, vEvalpoints, 2)\n\nS = NSurface(uEvalpoints, vEvalpoints, 2, pM)\nnothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"The plotSurface function has an optional argument tangents to plot vectors at the points of the curve.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"using PlotlyJS\n\nplotSurface(S[1, 1], tangents=S[2,1], controlPoints=NSurface.controlPoints, enforceRatio=false)\nt = plotSurface(S[1, 1], tangents=S[2,1], controlPoints=NSurface.controlPoints, enforceRatio=false) # hide\nsavefig(t, \"surface3Dder.html\"); nothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"../surface3Dder.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Refining-a-Surface","page":"Surfaces","title":"Refining a Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Based on the principles of knot insertion, several knots can be inserted into a surface (without changing the points the surface describes) by the refine function.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"BSurfaceRef = refine(BSurface; U=[0.5, 0.5, 0.72], V=[0.2, 0.42])\n\nplotPatches([BSurfaceRef], enforceRatio=false, plotControlPoints=true)\nt = plotPatches([BSurfaceRef], enforceRatio=false, plotControlPoints=true) # hide\nsavefig(t, \"surfaceRefined.html\"); nothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"../surfaceRefined.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"note: Note\nRefining a surface does not change the points in space described by the surface. Effectively, in the plots it can be seen that the number of control points is increased.  However, also underlying properties such as the differentiability are changed.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Splitting-a-Surface","page":"Surfaces","title":"Splitting a Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To split a surface into multiple separate surfaces the function split is provided which returns an array of surfaces.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"sVec = split(BSurface, U=[0.5,0.75], V=[0.6])\n\nplotPatches(sVec, enforceRatio=false, plotControlPoints=false)\nt = plotPatches(sVec, enforceRatio=false, plotControlPoints=false) # hide\nsavefig(t, \"surfaceSplit.html\"); nothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"../surfaceSplit.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"To equally split a surface into n times m surfaces as second and third argument an integer can be provided:","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"sVec = split(BSurface, 3, 2) # split into 3 x 2 surfaces","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"","category":"page"},{"location":"surfaces/#Removing-Knots-from-a-Surface","page":"Surfaces","title":"Removing Knots from a Surface","text":"","category":"section"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"Based on the principles of knot removal, an interior knot can potentially be removed multiple times from a surface (without changing the points the surface describes) by the removeKnotU and the removeKnotV functions.","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"# --- surface with removable knots\np = 3\nkVec = Float64[0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2]\n\nP1 = SVector(0.0, 0.0, 0.0)\nP2 = SVector(0.0, 2.0, 0.0)\nP3 = SVector(1.5, 3.0, 0.0)\nP4 = SVector(3.0, 3.0, 0.0)\nP5 = SVector(4.5, 3.0, 0.0)\nP6 = SVector(6.0, 2.0, 0.0)\nP7 = SVector(6.0, 0.0, 0.0)\n\ncP = [P1 , P2 , P3 , P4 , P5 , P6 , P7 ]\n\nP1 = SVector(0.0, 0.0, 2.0)\nP2 = SVector(0.0, 2.0, 2.0)\nP3 = SVector(1.5, 3.0, 2.0)\nP4 = SVector(3.0, 3.0, 2.0)\nP5 = SVector(4.5, 3.0, 2.0)\nP6 = SVector(6.0, 2.0, 2.0)\nP7 = SVector(6.0, 0.0, 2.0)\n\ncP2 = [P1 , P2 , P3 , P4 , P5 , P6 , P7 ]\n\ncontrolPoints = [[cP, cP2][j][i] for i in 1:7, j in 1:2] \n\nBS1 = BsplineSurface(Bspline(p, kVec), Bspline(1, [0.0,0.0,1.0,1.0]), controlPoints)\n\n\n# --- remove knot\nBS2 = removeKnotU(BS1, 0.5, 1) # remove knot once\n\n\n# --- plot before and after\nt1 = plotPatches([BS1], enforceRatio=true, plotControlPoints=true)\nt2 = plotPatches([BS2], enforceRatio=true, plotControlPoints=true)\n\nuEval = vEval = collect(0:0.005:1.0)\n\nS1 = BS1(uEval, vEval)\nS2 = BS2(uEval, vEval)\n\nx, t1 = plotSurface(S1, controlPoints=BS1.controlPoints, returnTrace=true)\nx, t2 = plotSurface(S2, controlPoints=BS2.controlPoints, returnTrace=true)\n\nfig = make_subplots(\n    rows=1, cols=2,\n    specs=fill(Spec(kind=\"scene\"), 1, 2)\n)\n\nfor i in eachindex(t1)\n    add_trace!(fig, t1[i], row=1, col=1)\nend\nfor i in eachindex(t2)\n    add_trace!(fig, t2[i], row=1, col=2)\nend\n\nfig\nsavefig(fig, \"surfaceRemoved.html\"); nothing # hide","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"<object data=\"../surfaceRemoved.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"surfaces/","page":"Surfaces","title":"Surfaces","text":"note: Note\nRemoving a knot from a surface is only possible when the continuity of the surface is sufficient at the knot. A central part of the removeKnot functions is to verify if the knot can actually be removed. If not, warnings are generated, indicating the encountered limitations.","category":"page"},{"location":"fileio/#File-I/O","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"Two means are provided to read data from files.","category":"page"},{"location":"fileio/#Step-files","page":"File I/O","title":"Step files","text":"","category":"section"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"To read .step and .stp files containing B-spline surfaces and/or NURBS surfaces a function readStep is provided.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"note: Note\nSo far only reading B-spline surfaces (called B_SPLINE_SURFACE_WITH_KNOTS in .step and .stp) and NURBS surfaces (as a BOUNDED_SURFACE() in .step and .stp) is supported.  However, reading curves should not be too dificult to implement.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"using NURBS # hide\nPatches = readStep(\"assets/torus.stp\")\n\nusing PlotlyJS\nplotPatches(Patches, plotControlPoints=false, resolution=0.25)\nt = plotPatches(Patches, plotControlPoints=false, resolution=0.25) # hide\nsavefig(t, \"torus.html\"); nothing # hide","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"<object data=\"../torus.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"fileio/#Multipatch-Files","page":"File I/O","title":"Multipatch Files","text":"","category":"section"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"To read multipatch files as defined and provided by the nurbs Octave implementation and BEMBEL a function readMultipatch is provided.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"note: Note\nApart from these files the implementation in this package is done independendly from the Octave package. Similarities are accidentally (as it is also based on [1]). Also note, that the Octave package so far provides more functionality.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"using NURBS # hide\nPatches = readMultipatch(\"assets/sphere.dat\")\n\nusing PlotlyJS\nplotPatches(Patches, plotControlPoints=true, resolution=0.1)\nt = plotPatches(Patches, plotControlPoints=true, resolution=0.1) # hide\nsavefig(t, \"sphere.html\"); nothing # hide","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"<object data=\"../sphere.html\" type=\"text/html\"  style=\"width:100%;height:50vh;\"> </object>","category":"page"},{"location":"knotInsertion/#knotInsert","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"The insertion of knots into a knot vector of a curve or a surface without changing the curve or the surface is a fundamental operation. It is of use for [1, p. 142]:","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"evaluating points and derivatives on curves and surfaces\nsubdividing curves and surfaces\nadding control points in order to increase flexibility for interactive design control","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Inserting-Knots-into-a-Curve","page":"Knot Insertion","title":"Inserting Knots into a Curve","text":"","category":"section"},{"location":"knotInsertion/#Inserting-a-Single-Knot","page":"Knot Insertion","title":"Inserting a Single Knot","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"A given curve bmc(u) = sum_i=1^B N_ip(u) bmp_i defined on the knot vector","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"U = u_1 dots u_M","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"can be represented equivalently by inserting baru into U at the kth position resulting in the extended knot vector","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"barU = baru_1=u_1 dots baru_k = u_k baru_k+1=baru baru_k+2=u_k+1 dots baru_barM = u_M ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"as","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"bmc(u) = sum_i=1^barB barN_ip(u) barbmp_i ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"where barM = M+1 and barB = B+1 and the barN_ip are the pth degree basis functions defined on barU.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"note: Note\nHence, there are two tasks to fulfill:determining the position index k and the resulting barU for a given baru\ndetermining the barbmp_i","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"While the first one is a standard task, the second one can be computed as [1, p. 143]","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"barbmp_i = alpha_i bmp_i + (1 - alpha_i) bmp_i-1","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"with the coefficients","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"alpha_i = begincases 1  i leq k - p  cfracbaru - u_i  u_i+p - u_i  k - p + 1 leq i leq k  0  i geq k + 1 endcases ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"In consequence, p new control points have to be computed replacing p-1 existing ones.","category":"page"},{"location":"knotInsertion/#Inserting-Mulitple-Knots","page":"Knot Insertion","title":"Inserting Mulitple Knots","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"If the point baru to be inserted, already exists s times in U and shall be inserted r additional times, the above formula generalizes to [1, p. 149]","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"barbmp_ir = alpha_ir barbmp_i r-1 + (1 - alpha_ir) barbmp_i-1 r-1","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"with barbmp_i0 = bmp_i and","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"alpha_ir = begincases 1  i leq k - p + r - 1  cfracbaru - u_i  u_i+p-r+1 - u_i  k - p + r leq i leq k - s  0  i geq k - s + 1 endcases ","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"note: Note\np-s+r-1 new control points are computed.\np-s-1 control points are replaced starting at index k - p + 1.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Inserting-Knots-into-a-Surface","page":"Knot Insertion","title":"Inserting Knots into a Surface","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"Inserting a knot into a surface (either along u or along v) basically corresponds to applying the knot insertion process from a curve to the grid of control points of the surface.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Knot-Refinement","page":"Knot Insertion","title":"Knot Refinement","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"Knot refinement is the insertion of several different knots into a surface or a curve.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"","category":"page"},{"location":"knotInsertion/#Splitting-Curves-and-Surfaces","page":"Knot Insertion","title":"Splitting Curves and Surfaces","text":"","category":"section"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"By inserting a knot into a surface such that the knot multiplicity is equal to the degree of the curve, the curve can be separated into two curves. The two curves describe the same points in space as the original curve.","category":"page"},{"location":"knotInsertion/","page":"Knot Insertion","title":"Knot Insertion","text":"Analogously, a surface can be split into multiple surfaces via knot insertion.","category":"page"},{"location":"#NURBS.jl","page":"Introduction","title":"NURBS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides functionality to define and evaluate B-spline, Curry-Schoenberg, and NURBS (non-uniform rational B-spline) basis functions, their derivatives, as well as curves and surfaces based on B-spline and NURBS basis functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The following aspects are implemented (✓) and planned (⌛):","category":"page"},{"location":"#B-spline,-Curry-Schoenberg-and-NURBS-evaluation","page":"Introduction","title":"B-spline, Curry-Schoenberg & NURBS evaluation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"✓ Basis & derivatives\n✓ Curves & derivatives\n✓ Surfaces & derivatives","category":"page"},{"location":"#Fundamental-operations","page":"Introduction","title":"Fundamental operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"✓ File I/O (.step)\n✓ Knot manipulation\nknot insertion / refinement\nknot removal\nsplitting of curves and surfaces\n✓ Transformation of curves and surfaces\nscaling\ntranslating\nrotating\nmirroring\n⌛ Degree elevation / reduction\n⌛ Construction of common geometries","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Basically, chapters 2-4 of [1] are implemented so far (adapted to 1-based indexing).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nOpen knot vectors are assumed everywhere, if not stated otherwise.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThe parametric space is assumed to be 0 1 or 01^2  everywhere.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Installing NURBS is done by entering the package manager (enter ] at the julia REPL) and issuing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add NURBS ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#refs","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The implementation is based on","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1] L. Piegl, The NURBS Book, Berlin Heidelberg, Springer-Verlag, 1997.\n[2] R.N. Simpson, et. al, A Two-Dimensional Isogeometric Boundary Element Method for Elastostatic Analysis, Comput. Methods Appl. Mech. Engrg., 2012.\n[3] C. de Boor, A Practical Guide to Splines, revised ed., Appl. Math. Sci., vol. 27, Springer-Verlag, New York, 2001.\n[4] L. Beirão da Veiga, A. Buffa, G. Sangalli, R. Vázquez, Analysis-suitable T-splines of arbitrary degree: Definition, linear independence and approximation properties, Math. Models Methods Appl. Sci. 23, 2013.","category":"page"}]
}
